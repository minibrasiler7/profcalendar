{% extends "base.html" %}

{% block title %}{% if is_current %}Leçon en cours{% else %}Prochain cours{% endif %} - TeacherPlanner{% endblock %}

{% block extra_css %}
<!-- PDF.js pour l'affichage des PDF -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>
// Configuration du worker PDF.js
if (typeof pdfjsLib !== 'undefined') {
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    console.log('PDF.js worker configuré');
}
</script>
<style>
.lesson-container {
    max-width: 1400px;
    margin: 0 auto;
    padding-bottom: 2rem;
    min-height: calc(100vh - 200px);
}

.lesson-header {
    background-color: var(--white);
    padding: 1.5rem;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-sm);
    margin-bottom: 1.5rem;
}

.lesson-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.lesson-title h1 {
    margin: 0;
    font-size: 1.75rem;
    display: flex;
    align-items: center;
    gap: 1rem;
}

.lesson-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    border-radius: 9999px;
    font-size: 0.875rem;
    font-weight: 500;
}

.lesson-badge.current {
    background-color: #FEF3C7;
    color: #92400E;
}

.lesson-badge.next {
    background-color: #DBEAFE;
    color: #1E40AF;
}

.lesson-details {
    display: flex;
    gap: 2rem;
    margin-top: 0.5rem;
    color: var(--gray-color);
}

.lesson-detail {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.lesson-main {
    display: grid;
    grid-template-columns: 1.5fr 1fr 1fr;
    gap: 1.5rem;
    min-height: 500px;
    margin-bottom: 2rem;
    transition: all 0.3s ease;
}

/* Dispositions alternatives - Focus Planification = 50% gauche, autres empilées à droite */
.lesson-main.layout-planning-focus {
    grid-template-columns: 1fr 1fr !important;
    grid-template-rows: auto auto !important;
    grid-template-areas: 
        "planning attendance"
        "planning resources" !important;
}

.lesson-main.layout-planning-focus .planning-section {
    grid-area: planning;
}

.lesson-main.layout-planning-focus .attendance-section {
    grid-area: attendance;
}

.lesson-main.layout-planning-focus .resources-section {
    grid-area: resources;
}

/* Focus Présences = 50% droite, autres empilées à gauche */
.lesson-main.layout-attendance-focus {
    grid-template-columns: 1fr 1fr !important;
    grid-template-rows: auto auto !important;
    grid-template-areas: 
        "planning attendance"
        "resources attendance" !important;
}

.lesson-main.layout-attendance-focus .planning-section {
    grid-area: planning;
}

.lesson-main.layout-attendance-focus .attendance-section {
    grid-area: attendance;
}

.lesson-main.layout-attendance-focus .resources-section {
    grid-area: resources;
}

/* Focus Ressources = 50% droite, autres empilées à gauche */
.lesson-main.layout-resources-focus {
    grid-template-columns: 1fr 1fr !important;
    grid-template-rows: auto auto !important;
    grid-template-areas: 
        "planning resources"
        "attendance resources" !important;
}

.lesson-main.layout-resources-focus .planning-section {
    grid-area: planning;
}

.lesson-main.layout-resources-focus .attendance-section {
    grid-area: attendance;
}

.lesson-main.layout-resources-focus .resources-section {
    grid-area: resources;
}

/* Effets visuels discrets pour les sections focus */
.lesson-main.layout-planning-focus .planning-section {
    transform: scale(1.02);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    border: 1px solid #e5e7eb;
}

.lesson-main.layout-resources-focus .resources-section {
    transform: scale(1.02);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    border: 1px solid #e5e7eb;
}

.lesson-main.layout-attendance-focus .attendance-section {
    transform: scale(1.02);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    border: 1px solid #e5e7eb;
}

.lesson-main.layout-vertical {
    grid-template-columns: 1fr;
    gap: 1rem;
}

.lesson-main.layout-vertical .planning-section {
    order: 1;
}

.lesson-main.layout-vertical .resources-section {
    order: 2;
}

.lesson-main.layout-vertical .attendance-section {
    order: 3;
}

.planning-section, .resources-section, .attendance-section {
    background-color: var(--white);
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-sm);
    padding: 1.5rem;
    display: flex;
    flex-direction: column;
    min-height: 400px;
    height: auto;
    transition: all 0.3s ease;
}

.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--light-gray);
}

.section-title {
    font-size: 1.25rem;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.planning-content {
    flex: 1;
    overflow-y: auto;
}

.planning-item {
    margin-bottom: 2rem;
}

.planning-item h3 {
    color: var(--primary-color);
    margin-bottom: 0.5rem;
    font-size: 1.125rem;
}

.planning-description {
    color: var(--gray-color);
    line-height: 1.6;
    white-space: pre-wrap;
}

/* Styles pour les checkboxes dans la planification */
.planning-checklist-item {
    display: flex;
    align-items: flex-start;
    gap: 0.5rem;
    margin: 0.5rem 0;
    min-height: 1.5rem;
}

.planning-checkbox {
    margin-top: 0.125rem;
    cursor: pointer;
    width: 1rem;
    height: 1rem;
}

.planning-checkbox-label {
    flex: 1;
    cursor: pointer;
    user-select: none;
}

.planning-checkbox:checked + .planning-checkbox-label {
    text-decoration: line-through;
    opacity: 0.7;
}

#planningDescription {
    font-family: monospace;
    tab-size: 4;
}

.checklist-help {
    font-size: 0.75rem;
    color: var(--gray-color);
    margin-top: 0.5rem;
    font-style: italic;
}

.resources-content {
    flex: 1;
    overflow-y: auto;
}

.no-resources {
    text-align: center;
    padding: 3rem;
    color: var(--gray-color);
}

.no-resources i {
    font-size: 3rem;
    margin-bottom: 1rem;
    opacity: 0.5;
}

/* Styles pour les onglets de suivi */
.tracking-tabs {
    display: flex;
    border-bottom: 2px solid var(--light-gray);
    margin-bottom: 1.5rem;
}

.tracking-tab {
    padding: 0.75rem 1.5rem;
    background: none;
    border: none;
    border-bottom: 3px solid transparent;
    color: var(--gray-color);
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.tracking-tab:hover {
    color: var(--primary-color);
}

.tracking-tab.active {
    color: var(--primary-color);
    border-bottom-color: var(--primary-color);
}

.tracking-content {
    display: none;
}

.tracking-content.active {
    display: block;
}

/* Styles pour la section présences */
.attendance-content {
    flex: 1;
    overflow-y: auto;
}

.attendance-stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.stat-item {
    text-align: center;
    padding: 0.5rem;
    border-radius: 0.375rem;
    background-color: var(--light-gray);
}

.stat-item.present {
    background-color: #D1FAE5;
    color: #065F46;
}

.stat-item.absent {
    background-color: #FEE2E2;
    color: #991B1B;
}

.stat-item.late {
    background-color: #FEF3C7;
    color: #92400E;
}

.stat-value {
    font-size: 1.5rem;
    font-weight: 700;
}

.stat-label {
    font-size: 0.75rem;
}

.students-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.student-attendance {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem;
    border-radius: 0.375rem;
    background-color: var(--light-gray);
    transition: all 0.2s ease;
}

.student-attendance.present {
    background-color: #D1FAE5;
}

.student-attendance.absent {
    background-color: #FEE2E2;
}

.student-attendance.late {
    background-color: #FEF3C7;
}

.student-info {
    flex: 1;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    user-select: none;
}

.student-avatar {
    width: 32px;
    height: 32px;
    background-color: var(--primary-color);
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.75rem;
    font-weight: 600;
}

.student-attendance.absent .student-avatar {
    background-color: var(--danger-color);
}

.student-attendance.late .student-avatar {
    background-color: var(--warning-color);
}

.student-name {
    font-weight: 500;
}

.student-attendance.absent .student-name {
    color: var(--danger-color);
    text-decoration: line-through;
}

.student-attendance.late .student-name {
    color: var(--warning-color);
}

.late-controls {
    display: flex;
    align-items: center;
    gap: 0.25rem;
}

.late-minutes {
    width: 60px;
    padding: 0.25rem;
    border: 1px solid #D1D5DB;
    border-radius: 0.25rem;
    font-size: 0.875rem;
    text-align: center;
}

.late-minutes:focus {
    outline: none;
    border-color: var(--warning-color);
}

.btn-late {
    width: 32px;
    height: 32px;
    border: none;
    background-color: #F3F4F6;
    color: var(--gray-color);
    border-radius: 0.25rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
}

.btn-late:hover {
    background-color: var(--warning-color);
    color: white;
}

.student-attendance.late .btn-late {
    background-color: var(--warning-color);
    color: white;
}

/* Styles pour les sanctions */
.sanctions-content {
    flex: 1;
    overflow-y: auto;
}

.sanctions-table-container {
    overflow-x: auto;
    border-radius: var(--border-radius);
    border: 1px solid var(--light-gray);
    background-color: var(--white);
}

.sanctions-table {
    width: 100%;
    border-collapse: collapse;
    min-width: 600px;
}

.sanctions-table th {
    background-color: var(--light-gray);
    padding: 0.75rem;
    text-align: center;
    font-weight: 600;
    color: var(--dark-color);
    border-bottom: 2px solid var(--primary-color);
    position: sticky;
    top: 0;
    z-index: 1;
    font-size: 0.875rem;
}

.sanctions-table th.student-column {
    text-align: left;
    min-width: 150px;
    max-width: 150px;
}

.sanctions-table th.sanction-column {
    min-width: 100px;
}

.sanctions-table td {
    padding: 0.5rem;
    border-bottom: 1px solid var(--light-gray);
    vertical-align: middle;
}

.sanctions-table tr:hover {
    background-color: #F9FAFB;
}

.student-name {
    font-weight: 500;
    color: var(--dark-color);
    text-align: left;
    font-size: 0.875rem;
}

.sanction-count {
    text-align: center;
}

.count-controls {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.25rem;
}

.count-btn {
    width: 24px;
    height: 24px;
    border: 1px solid var(--light-gray);
    background-color: var(--white);
    color: var(--gray-color);
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.625rem;
    transition: all 0.2s ease;
}

.count-btn:hover {
    background-color: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
    transform: scale(1.1);
}

.count-btn.decrease:hover {
    background-color: var(--danger-color);
    border-color: var(--danger-color);
}

.count-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
}

.count-display {
    font-weight: 600;
    font-size: 0.875rem;
    min-width: 24px;
    text-align: center;
    color: var(--dark-color);
    padding: 0.125rem 0.25rem;
    border-radius: var(--border-radius);
    background-color: var(--light-gray);
}

.count-display.warning {
    background-color: #FEF3C7;
    color: #92400E;
}

.count-display.danger {
    background-color: #FEE2E2;
    color: #991B1B;
}

.lesson-controls {
    display: flex;
    align-items: center;
    gap: 2rem;
}

.layout-controls {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.layout-label {
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--gray-color);
}

.layout-buttons {
    display: flex;
    gap: 0.25rem;
    background-color: var(--light-gray);
    padding: 0.25rem;
    border-radius: 0.5rem;
}

.layout-btn {
    width: 40px;
    height: 40px;
    border: none;
    background-color: transparent;
    color: var(--gray-color);
    border-radius: 0.375rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    font-size: 1rem;
}

.layout-btn:hover {
    background-color: var(--white);
    color: var(--primary-color);
    transform: scale(1.05);
}

.layout-btn.active {
    background-color: var(--primary-color);
    color: white;
    box-shadow: 0 2px 4px rgba(79, 70, 229, 0.3);
}

.timer-widget {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 0.75rem 1.5rem;
    background-color: var(--light-gray);
    border-radius: var(--border-radius);
}

.timer-display {
    font-size: 1.5rem;
    font-weight: 600;
    font-family: monospace;
}

.timer-controls {
    display: flex;
    gap: 0.5rem;
}

.timer-btn {
    width: 36px;
    height: 36px;
    border: none;
    background-color: var(--white);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
}

.timer-btn:hover {
    transform: scale(1.1);
    box-shadow: var(--shadow-sm);
}

/* Indicateur de sauvegarde */
.saving-indicator {
    position: fixed;
    top: 80px;
    right: 20px;
    background-color: #3B82F6;
    color: white;
    padding: 0.75rem 1rem;
    border-radius: 0.5rem;
    display: none;
    align-items: center;
    gap: 0.5rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    z-index: 1000;
}

.saving-indicator.show {
    display: flex;
}

.saving-indicator.success {
    background-color: #10B981;
}

.saving-indicator.error {
    background-color: #EF4444;
}

@media (max-width: 900px) {
    .lesson-main,
    .lesson-main.layout-planning-focus,
    .lesson-main.layout-resources-focus,
    .lesson-main.layout-attendance-focus {
        grid-template-columns: 1fr !important;
        gap: 1rem;
    }
}

@media (min-width: 901px) and (max-width: 1200px) {
    .lesson-main {
        grid-template-columns: 1fr 1fr 1fr;
    }
    
    .lesson-main.layout-planning-focus {
        grid-template-columns: 2fr 1fr 1fr !important;
    }

    .lesson-main.layout-resources-focus {
        grid-template-columns: 1fr 2fr 1fr !important;
    }

    .lesson-main.layout-attendance-focus {
        grid-template-columns: 1fr 1fr 2fr !important;
    }
}

@media (max-width: 1200px) {
    .lesson-container {
        min-height: auto;
        padding-bottom: 2rem;
    }

    .planning-section, .resources-section, .attendance-section, .seating-plan-section {
        min-height: 300px;
    }
    
    .lesson-controls {
        flex-direction: column;
        gap: 1rem;
        align-items: flex-start;
    }
    
    .layout-controls {
        width: 100%;
        justify-content: space-between;
    }
    
    .layout-buttons {
        flex-wrap: wrap;
    }
}

@media (max-width: 768px) {
    .layout-label {
        display: none;
    }
    
    .layout-btn {
        width: 36px;
        height: 36px;
        font-size: 0.875rem;
    }
}
</style>
{% endblock %}

{% block content %}
<div class="lesson-container">
    <!-- En-tête de la leçon -->
    <div class="lesson-header">
        <div class="lesson-info">
            <div>
                <div class="lesson-title">
                    <h1>
                        {% if is_current %}
                        <span class="lesson-badge current">
                            <i class="fas fa-circle"></i> En cours
                        </span>
                        {% else %}
                        <span class="lesson-badge next">
                            <i class="fas fa-clock"></i> Prochain cours
                        </span>
                        {% endif %}
                        {{ lesson.classroom.name }} - {{ lesson.classroom.subject }}
                    </h1>
                </div>
                <div class="lesson-details">
                    <div class="lesson-detail">
                        <i class="fas fa-calendar"></i>
                        <span>
                            {% set day_names = {
                                'Monday': 'Lundi',
                                'Tuesday': 'Mardi', 
                                'Wednesday': 'Mercredi',
                                'Thursday': 'Jeudi',
                                'Friday': 'Vendredi',
                                'Saturday': 'Samedi',
                                'Sunday': 'Dimanche'
                            } %}
                            {% set month_names = {
                                'January': 'janvier',
                                'February': 'février',
                                'March': 'mars',
                                'April': 'avril',
                                'May': 'mai',
                                'June': 'juin',
                                'July': 'juillet',
                                'August': 'août',
                                'September': 'septembre',
                                'October': 'octobre',
                                'November': 'novembre',
                                'December': 'décembre'
                            } %}
                            {{ day_names[lesson_date.strftime('%A')] }} {{ lesson_date.strftime('%d') }} {{ month_names[lesson_date.strftime('%B')] }} {{ lesson_date.strftime('%Y') }}
                        </span>
                    </div>
                    <div class="lesson-detail">
                        <i class="fas fa-clock"></i>
                        <span>Période {{ lesson.period_number }} ({{ lesson.start_time.strftime('%H:%M') }} - {{ lesson.end_time.strftime('%H:%M') }})</span>
                    </div>
                </div>
            </div>

            <div class="lesson-controls">
                <!-- Contrôles de disposition -->
                <div class="layout-controls">
                    <span class="layout-label">Disposition :</span>
                    <div class="layout-buttons">
                        <button class="layout-btn active" data-layout="default" title="Disposition par défaut (3 colonnes)">
                            <i class="fas fa-columns"></i>
                        </button>
                        <button class="layout-btn" data-layout="planning-focus" title="Focus planification (planification large)">
                            <i class="fas fa-list-alt"></i>
                        </button>
                        <button class="layout-btn" data-layout="resources-focus" title="Focus ressources (ressources large)">
                            <i class="fas fa-folder-open"></i>
                        </button>
                        <button class="layout-btn" data-layout="attendance-focus" title="Focus présences (présences large)">
                            <i class="fas fa-user-check"></i>
                        </button>
                        <button class="layout-btn" data-layout="vertical" title="Disposition verticale (1 colonne)">
                            <i class="fas fa-bars"></i>
                        </button>
                    </div>
                </div>
                
                {% if is_current %}
                <div class="timer-widget">
                    <div class="timer-display" id="lessonTimer">{{ time_remaining }}</div>
                    <div class="timer-controls">
                        <button class="timer-btn" onclick="toggleTimer()" title="Pause/Reprendre">
                            <i class="fas fa-pause" id="timerIcon"></i>
                        </button>
                    </div>
                </div>
                {% endif %}
            </div>
        </div>
    </div>

    <!-- Contenu principal -->
    <div class="lesson-main">
        <!-- Section planification -->
        <div class="planning-section">
            <div class="section-header">
                <h2 class="section-title">
                    <i class="fas fa-clipboard-list"></i> Planification du cours
                </h2>
                <button class="edit-planning-btn" onclick="togglePlanningEdit()">
                    <i class="fas fa-edit"></i> <span id="editBtnText">Modifier</span>
                </button>
            </div>

            <div class="planning-content">
                <!-- Vue de lecture -->
                <div id="planningView" {% if not planning %}style="display: none;"{% endif %}>
                    <div class="planning-item">
                        <h3 id="planningTitleDisplay">{{ planning.title if planning else 'Cours sans titre' }}</h3>
                        <div class="planning-description" id="planningDescriptionDisplay">
                            {% if planning %}
                                {{ render_planning_with_checkboxes(planning) | safe }}
                            {% else %}
                                Aucune description
                            {% endif %}
                        </div>
                    </div>
                </div>

                <!-- Formulaire d'édition -->
                <div id="planningEdit" style="display: none;">
                    <form id="planningForm" onsubmit="savePlanning(event)">
                        <div class="form-group">
                            <label class="form-label">Titre du cours</label>
                            <input type="text"
                                   id="planningTitle"
                                   class="form-control"
                                   placeholder="Ex: Introduction aux fractions"
                                   value="{{ planning.title if planning else '' }}">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Description détaillée</label>
                            <textarea id="planningDescription"
                                      class="form-control"
                                      rows="8"
                                      placeholder="Objectifs du cours, activités prévues, exercices, devoirs...">{{ planning.description if planning else '' }}</textarea>
                            <div class="checklist-help">
                                Astuce : Commencez une ligne par "-" pour créer une case à cocher
                            </div>
                        </div>

                        <div class="form-actions">
                            <button type="submit" class="btn btn-primary">
                                <i class="fas fa-save"></i> Enregistrer
                            </button>
                            <button type="button" class="btn btn-outline" onclick="cancelPlanningEdit()">
                                Annuler
                            </button>
                        </div>
                    </form>
                </div>

                <!-- État vide -->
                {% if not planning %}
                <div id="emptyPlanning" class="no-resources">
                    <i class="fas fa-clipboard"></i>
                    <p>Aucune planification pour ce cours</p>
                    <button class="btn btn-primary" onclick="togglePlanningEdit()">
                        <i class="fas fa-plus"></i> Créer une planification
                    </button>
                </div>
                {% endif %}
            </div>
        </div>


        <!-- Section présences -->
        <div class="attendance-section">
            <div class="section-header">
                <h2 class="section-title">
                    <i class="fas fa-user-check"></i> Suivi des élèves
                </h2>
            </div>

            <!-- Onglets de suivi -->
            <div class="tracking-tabs">
                <button class="tracking-tab active" onclick="showTrackingTab('attendance')">
                    <i class="fas fa-user-check"></i> Présences
                </button>
                {% if imported_sanctions %}
                <button class="tracking-tab" onclick="showTrackingTab('sanctions')">
                    <i class="fas fa-exclamation-triangle"></i> Coches ({{ imported_sanctions|length }})
                </button>
                {% endif %}
                {% if seating_plan %}
                <button class="tracking-tab" onclick="showTrackingTab('seating-plan')">
                    <i class="fas fa-th"></i> Plan de classe
                </button>
                {% endif %}
            </div>

            <div class="attendance-content tracking-content active" id="attendance-content">
                <!-- Statistiques -->
                <div class="attendance-stats">
                    <div class="stat-item present">
                        <div class="stat-value" id="presentCount">0</div>
                        <div class="stat-label">Présents</div>
                    </div>
                    <div class="stat-item absent">
                        <div class="stat-value" id="absentCount">0</div>
                        <div class="stat-label">Absents</div>
                    </div>
                    <div class="stat-item late">
                        <div class="stat-value" id="lateCount">0</div>
                        <div class="stat-label">Retards</div>
                    </div>
                </div>

                <!-- Liste des élèves -->
                <div class="students-list">
                    {% for student in students %}
                    {% set attendance = attendance_records.get(student.id, {}) %}
                    {% set status = attendance.get('status', 'present') %}
                    {% set late_minutes = attendance.get('late_minutes', 0) %}

                    <div class="student-attendance {{ status }}"
                         id="student-{{ student.id }}"
                         data-student-id="{{ student.id }}"
                         data-status="{{ status }}">

                        <div class="student-info" onclick="toggleAttendance({{ student.id }})">
                            <div class="student-avatar">
                                {{ student.first_name[0] }}{{ student.last_name[0] if student.last_name else '' }}
                            </div>
                            <span class="student-name">{{ student.full_name }}</span>
                        </div>

                        <div class="late-controls">
                            <input type="number"
                                   class="late-minutes"
                                   id="late-{{ student.id }}"
                                   value="{{ late_minutes if status == 'late' else '' }}"
                                   min="1"
                                   max="120"
                                   placeholder="min">
                            <button class="btn-late"
                                    onclick="setLateStatus({{ student.id }})"
                                    title="Marquer en retard">
                                <i class="fas fa-clock"></i>
                            </button>
                        </div>
                    </div>
                    {% endfor %}
                </div>
            </div>

            <!-- Section sanctions -->
            {% if imported_sanctions %}
            <div class="sanctions-content tracking-content" id="sanctions-content">
                <div class="sanctions-table-container">
                    <table class="sanctions-table">
                        <thead>
                            <tr>
                                <th class="student-column">Élève</th>
                                {% for sanction in imported_sanctions %}
                                <th class="sanction-column">{{ sanction.name }}</th>
                                {% endfor %}
                            </tr>
                        </thead>
                        <tbody>
                            {% for student in students %}
                            <tr>
                                <td class="student-name">{{ student.full_name }}</td>
                                {% for sanction in imported_sanctions %}
                                <td class="sanction-count">
                                    <div class="count-controls">
                                        <button class="count-btn decrease" onclick="updateSanctionCount({{ student.id }}, {{ sanction.id }}, -1)">
                                            <i class="fas fa-minus"></i>
                                        </button>
                                        <span class="count-display" data-student="{{ student.id }}" data-sanction="{{ sanction.id }}">
                                            {{ sanctions_data[student.id][sanction.id] }}
                                        </span>
                                        <button class="count-btn increase" onclick="updateSanctionCount({{ student.id }}, {{ sanction.id }}, 1)">
                                            <i class="fas fa-plus"></i>
                                        </button>
                                    </div>
                                </td>
                                {% endfor %}
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>
            {% endif %}
            
            <!-- Section plan de classe -->
            {% if seating_plan %}
            <div class="seating-plan-content tracking-content" id="seating-plan-content">
                <div class="seating-plan-container">
                    <div class="seating-plan-viewer" id="seating-plan-viewer">
                        <div class="seating-workspace" id="seating-workspace">
                            <!-- Le plan de classe sera affiché ici -->
                        </div>
                    </div>
                </div>
            </div>
            {% endif %}
        </div>
        <!-- Fin de attendance-section -->

        <!-- Section ressources -->
        <div class="resources-section">
            <div class="section-header">
                <h2 class="section-title">
                    <i class="fas fa-folder-open"></i> Ressources du cours
                </h2>
                <div class="resource-controls">
                    <button class="resource-btn" onclick="refreshResources()" title="Actualiser">
                        <i class="fas fa-sync-alt"></i>
                    </button>
                    <a href="{{ url_for('file_manager.index') }}" class="add-resource-btn" target="_blank">
                        <i class="fas fa-plus"></i> Gestionnaire
                    </a>
                </div>
            </div>

            <div class="resources-content" id="resourcesContent">
                <!-- Chargement initial -->
                <div class="resources-loading" id="resourcesLoading">
                    <i class="fas fa-spinner fa-spin"></i>
                    <p>Chargement des ressources...</p>
                </div>

                <!-- Ressources épinglées -->
                <div class="pinned-resources" id="pinnedResources" style="display: none;">
                    <div class="pinned-header">
                        <i class="fas fa-thumbtack"></i>
                        <span>Ressources épinglées</span>
                    </div>
                    <div class="pinned-list" id="pinnedList">
                        <!-- Les ressources épinglées seront chargées ici -->
                    </div>
                </div>

                <!-- Navigation des dossiers -->
                <div class="folder-navigation" id="folderNavigation" style="display: none;">
                    <div class="breadcrumb" id="resourceBreadcrumb">
                        <span class="breadcrumb-item active" data-path="" onclick="navigateToFolder('')">
                            <i class="fas fa-home"></i> Racine
                        </span>
                    </div>
                </div>

                <!-- Arborescence des ressources -->
                <div class="resources-tree" id="resourcesTree" style="display: none;">
                    <!-- L'arborescence sera chargée ici -->
                </div>

                <!-- État vide -->
                <div class="no-resources" id="noResources" style="display: none;">
                    <i class="fas fa-folder-open"></i>
                    <p>Aucune ressource dans cette classe</p>
                    <p style="font-size: 0.875rem; margin-top: 0.5rem;">
                        Utilisez le gestionnaire de fichiers pour ajouter des ressources à cette classe
                    </p>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Indicateur de sauvegarde -->
<div class="saving-indicator" id="savingIndicator">
    <i class="fas fa-spinner fa-spin"></i>
    <span id="savingText">Sauvegarde...</span>
</div>

<!-- Modal Viewer/Annotateur -->
<div class="file-viewer-modal" id="fileViewerModal">
    <div class="viewer-header">
        <div class="viewer-title">
            <span id="pageInfo" class="page-info">Page 1 / 1</span>
        </div>
        <div class="viewer-tools">
            <!-- Navigation PDF -->
            <div class="tool-group">
                <button class="tool-btn" id="prevPageBtn" onclick="previousPage()" title="Page précédente">
                    <i class="fas fa-chevron-left"></i>
                </button>
                <button class="tool-btn" id="nextPageBtn" onclick="nextPage()" title="Page suivante">
                    <i class="fas fa-chevron-right"></i>
                </button>
            </div>
            
            <!-- Outils de dessin -->
            <div class="tool-group">
                <button class="tool-btn active" id="penTool" title="Stylo" data-tool="pen">
                    <i class="fas fa-pen"></i>
                </button>
                <button class="tool-btn" id="highlighterTool" title="Surligneur" data-tool="highlighter">
                    <i class="fas fa-highlighter"></i>
                </button>
                <button class="tool-btn" id="eraserTool" title="Gomme" data-tool="eraser">
                    <i class="fas fa-eraser"></i>
                </button>
            </div>
            
            <!-- Couleurs -->
            <div class="color-picker-container">
                <div class="preset-colors">
                    <button class="color-btn active" data-color="#000000" style="background-color: #000000" title="Noir"></button>
                    <button class="color-btn" data-color="#EF4444" style="background-color: #EF4444" title="Rouge"></button>
                    <button class="color-btn" data-color="#F59E0B" style="background-color: #F59E0B" title="Orange"></button>
                    <button class="color-btn" data-color="#EAB308" style="background-color: #EAB308" title="Jaune"></button>
                    <button class="color-btn" data-color="#22C55E" style="background-color: #22C55E" title="Vert"></button>
                    <button class="color-btn" data-color="#3B82F6" style="background-color: #3B82F6" title="Bleu"></button>
                </div>
                <input type="color" id="annotationColor" value="#000000" title="Couleur personnalisée">
            </div>
            
            <div class="stroke-width-container">
                <input type="range" id="strokeWidth" min="1" max="20" value="3" title="Épaisseur">
                <span id="strokeWidthValue">3</span>
            </div>
            
            <!-- Actions -->
            <div class="tool-group">
                <button class="tool-btn" id="saveBtn" title="Sauvegarder maintenant" onclick="saveAnnotations()">
                    <i class="fas fa-save"></i>
                </button>
                <button class="tool-btn" id="undoBtn" title="Annuler">
                    <i class="fas fa-undo"></i>
                </button>
                <button class="tool-btn" id="clearAllBtn" title="Tout effacer">
                    <i class="fas fa-trash"></i>
                </button>
                <!-- Bouton debug supprimé pour simplifier -->
            </div>
        </div>
        <button class="close-viewer" onclick="closeFileViewer()">
            <i class="fas fa-times"></i>
        </button>
    </div>
    <div class="viewer-content">
        <!-- Barre latérale des pages - permanente à gauche -->
        <div class="page-sidebar show" id="pageSidebar">
            <div class="sidebar-header">
                <h6><i class="fas fa-copy"></i> Pages</h6>
            </div>
            <div class="page-thumbnails scrollable" id="pageThumbnails">
                <!-- Les miniatures seront générées ici -->
            </div>
        </div>
        
        <!-- Zone d'affichage principal -->
        <div class="viewer-container" id="viewerContainer">
            <div class="pdf-viewer-container">
                <canvas id="pdfCanvas" class="pdf-canvas"></canvas>
                <canvas id="annotationCanvas" class="annotation-canvas"></canvas>
            </div>
        </div>
    </div>
    <div class="viewer-footer">
        <div class="save-status" id="saveStatus">
<i class="fas fa-info-circle"></i> Sauvegarde à la fermeture
        </div>
    </div>
</div>

<script>
// Variables globales
const lessonDate = '{{ lesson_date.strftime("%Y-%m-%d") }}';
const periodNumber = {{ lesson.period_number }};
const classroomId = {{ lesson.classroom_id }};
let isEditingPlanning = false;

// Variables pour le système de sanctions
let initialSanctionCounts = {};
let sanctionCheckTimer = null;
let sanctionNotificationShown = false;
const NOTIFICATION_TIME_BEFORE_END = 3 * 60 * 1000; // 3 minutes en millisecondes
let checklistStates = {{ (planning.get_checklist_states() if planning else {}) | tojson }};
let checkboxUpdateTimeout = null;
let currentLayout = 'default';

// Fonction pour changer la disposition
function changeLayout(layout) {
    console.log('Changement de disposition vers:', layout);
    currentLayout = layout;
    
    const lessonMain = document.querySelector('.lesson-main');
    const layoutButtons = document.querySelectorAll('.layout-btn');
    const body = document.body;
    
    if (!lessonMain) {
        console.error('Element .lesson-main non trouvé');
        return;
    }
    
    // Supprimer toutes les classes de layout
    lessonMain.classList.remove('layout-planning-focus', 'layout-resources-focus', 'layout-attendance-focus', 'layout-vertical');
    
    // Ajouter la nouvelle classe si ce n'est pas default
    if (layout !== 'default') {
        const className = `layout-${layout}`;
        console.log('Ajout de la classe:', className);
        lessonMain.classList.add(className);
        
        console.log('Classes actuelles:', lessonMain.className);
        
        // Vérifier les styles calculés
        const computedStyle = window.getComputedStyle(lessonMain);
        console.log('Grid template columns calculé:', computedStyle.gridTemplateColumns);
        console.log('Largeur écran:', window.innerWidth + 'px');
    } else {
        console.log('Disposition par défaut - aucune classe ajoutée');
        const computedStyle = window.getComputedStyle(lessonMain);
        console.log('Grid template columns par défaut:', computedStyle.gridTemplateColumns);
    }
    
    // Mettre à jour les boutons actifs
    layoutButtons.forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.layout === layout) {
            btn.classList.add('active');
        }
    });
    
    // Sauvegarder la préférence
    localStorage.setItem('lessonLayout', layout);
    
    // Animation de confirmation visuelle
    lessonMain.style.transform = 'scale(0.98)';
    setTimeout(() => {
        lessonMain.style.transform = 'scale(1)';
    }, 150);
}

// Initialiser les contrôles de disposition
function initLayoutControls() {
    console.log('Initialisation des contrôles de disposition');
    
    // Charger la disposition sauvegardée
    const savedLayout = localStorage.getItem('lessonLayout') || 'default';
    console.log('Disposition sauvegardée:', savedLayout);
    changeLayout(savedLayout);
    
    // Ajouter les event listeners
    const layoutButtons = document.querySelectorAll('.layout-btn');
    console.log('Boutons de disposition trouvés:', layoutButtons.length);
    
    layoutButtons.forEach((btn, index) => {
        console.log(`Bouton ${index}:`, btn.dataset.layout);
        btn.addEventListener('click', () => {
            const layout = btn.dataset.layout;
            console.log('Clic sur bouton:', layout);
            changeLayout(layout);
        });
    });
}

// Fonction pour basculer l'édition de la planification
function togglePlanningEdit() {
    isEditingPlanning = !isEditingPlanning;

    const planningView = document.getElementById('planningView');
    const planningEdit = document.getElementById('planningEdit');
    const emptyPlanning = document.getElementById('emptyPlanning');
    const editBtn = document.querySelector('.edit-planning-btn');
    const editBtnText = document.getElementById('editBtnText');

    if (isEditingPlanning) {
        // Passer en mode édition
        if (planningView) planningView.style.display = 'none';
        if (emptyPlanning) emptyPlanning.style.display = 'none';
        planningEdit.style.display = 'block';
        editBtnText.textContent = 'Fermer';

        // Focus sur le titre
        document.getElementById('planningTitle').focus();
    } else {
        // Passer en mode lecture
        planningEdit.style.display = 'none';
        
        // Vérifier s'il y a du contenu de planification en regardant le titre
        const titleDisplay = document.getElementById('planningTitleDisplay');
        const hasPlanning = titleDisplay && titleDisplay.textContent.trim() && 
                           titleDisplay.textContent !== 'Cours sans titre';
        
        if (hasPlanning) {
            // Il y a une planification, afficher la vue de lecture
            if (planningView) planningView.style.display = 'block';
            if (emptyPlanning) emptyPlanning.style.display = 'none';
        } else {
            // Pas de planification, afficher l'état vide
            if (planningView) planningView.style.display = 'none';
            if (emptyPlanning) emptyPlanning.style.display = 'block';
        }
        editBtnText.textContent = 'Modifier';
    }
}

// Fonction pour gérer l'auto-conversion des tirets en checkboxes
document.getElementById('planningDescription').addEventListener('input', function(e) {
    const textarea = e.target;
    const cursorPos = textarea.selectionStart;
    const value = textarea.value;

    // Vérifier si on vient de taper un tiret en début de ligne
    if (e.inputType === 'insertText' && e.data === '-') {
        const lines = value.substring(0, cursorPos).split('\n');
        const currentLine = lines[lines.length - 1];

        // Si le tiret est au début de la ligne (avec éventuellement des espaces avant)
        if (currentLine.trim() === '-') {
            e.preventDefault();

            // Remplacer le tiret par [ ]
            const beforeCursor = value.substring(0, cursorPos - 1);
            const afterCursor = value.substring(cursorPos);
            const spaces = currentLine.match(/^\s*/)[0]; // Préserver l'indentation

            textarea.value = beforeCursor + spaces + '[ ] ' + afterCursor;

            // Placer le curseur après [ ]
            const newCursorPos = cursorPos - 1 + spaces.length + 4;
            textarea.setSelectionRange(newCursorPos, newCursorPos);
        }
    }
});

// Fonction pour échapper le HTML
function escapeHtml(text) {
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, m => map[m]);
}

// Fonction pour mettre à jour l'état d'une checkbox
async function updateCheckboxState(index, checked) {
    // Mettre à jour l'état local immédiatement
    checklistStates[index] = checked;

    // Afficher l'indicateur de sauvegarde
    showSavingIndicator();

    // Annuler le timeout précédent s'il existe
    if (checkboxUpdateTimeout) {
        clearTimeout(checkboxUpdateTimeout);
    }

    // Sauvegarder avec un petit délai pour éviter trop de requêtes
    checkboxUpdateTimeout = setTimeout(async () => {
        try {
            const response = await fetch('{{ url_for("planning.update_checklist_states") }}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({
                    date: lessonDate,
                    period_number: periodNumber,
                    checklist_states: checklistStates
                })
            });

            const result = await response.json();

            if (result.success) {
                showSavingIndicator('success', 'Sauvegardé');
            } else {
                // En cas d'erreur, rétablir l'état précédent
                checklistStates[index] = !checked;
                const checkbox = document.getElementById(`checkbox-${index}`);
                if (checkbox) {
                    checkbox.checked = !checked;
                }
                showSavingIndicator('error', 'Erreur de sauvegarde');
            }
        } catch (error) {
            console.error('Erreur:', error);
            // En cas d'erreur, rétablir l'état précédent
            checklistStates[index] = !checked;
            const checkbox = document.getElementById(`checkbox-${index}`);
            if (checkbox) {
                checkbox.checked = !checked;
            }
            showSavingIndicator('error', 'Erreur de connexion');
        }
    }, 500); // Délai de 500ms pour regrouper les changements
}

// Fonction pour afficher l'indicateur de sauvegarde
function showSavingIndicator(status = 'saving', message = 'Sauvegarde...') {
    const indicator = document.getElementById('savingIndicator');
    const text = document.getElementById('savingText');
    const icon = indicator.querySelector('i');

    // Réinitialiser les classes
    indicator.className = 'saving-indicator show';

    if (status === 'saving') {
        icon.className = 'fas fa-spinner fa-spin';
        text.textContent = message;
    } else if (status === 'success') {
        indicator.classList.add('success');
        icon.className = 'fas fa-check';
        text.textContent = message;
    } else if (status === 'error') {
        indicator.classList.add('error');
        icon.className = 'fas fa-exclamation-triangle';
        text.textContent = message;
    }

    // Masquer après 2 secondes si c'est un succès ou une erreur
    if (status !== 'saving') {
        setTimeout(() => {
            indicator.classList.remove('show');
        }, 2000);
    }
}

// Fonction pour annuler l'édition
function cancelPlanningEdit() {
    // Restaurer les valeurs d'origine
    const titleDisplay = document.getElementById('planningTitleDisplay');
    const descriptionDisplay = document.getElementById('planningDescriptionDisplay');

    if (titleDisplay && titleDisplay.textContent !== 'Cours sans titre') {
        document.getElementById('planningTitle').value = titleDisplay.textContent;

        // Récupérer la description originale depuis les données du serveur
        {% if planning %}
        document.getElementById('planningDescription').value = {{ planning.description | tojson }};
        {% else %}
        document.getElementById('planningDescription').value = '';
        {% endif %}
    }

    togglePlanningEdit();
}

// Fonction pour sauvegarder la planification
async function savePlanning(event) {
    event.preventDefault();

    const title = document.getElementById('planningTitle').value.trim();
    const description = document.getElementById('planningDescription').value.trim();

    const submitButton = event.target.querySelector('button[type="submit"]');
    const originalText = submitButton.innerHTML;

    // Désactiver le bouton et afficher un loader
    submitButton.disabled = true;
    submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Enregistrement...';

    try {
        const response = await fetch('{{ url_for("planning.save_lesson_planning") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({
                date: lessonDate,
                period_number: periodNumber,
                classroom_id: classroomId,
                title: title,
                description: description,
                checklist_states: checklistStates
            })
        });

        const result = await response.json();

        if (result.success) {
            // Recharger la page pour afficher les changements
            window.location.reload();
        } else {
            showPlanningNotification('error', result.message || 'Erreur lors de l\'enregistrement');
        }
    } catch (error) {
        console.error('Erreur:', error);
        showPlanningNotification('error', 'Erreur lors de la communication avec le serveur');
    } finally {
        submitButton.disabled = false;
        submitButton.innerHTML = originalText;
    }
}

// Fonction pour afficher une notification
function showPlanningNotification(type, message) {
    // Créer le conteneur de notifications s'il n'existe pas
    let container = document.querySelector('.notifications-container');
    if (!container) {
        container = document.createElement('div');
        container.className = 'notifications-container';
        container.style.cssText = 'position: fixed; top: 80px; right: 20px; z-index: 1000;';
        document.body.appendChild(container);
    }

    // Créer la notification
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.style.cssText = `
        background-color: ${type === 'success' ? '#D1FAE5' : '#FEE2E2'};
        color: ${type === 'success' ? '#065F46' : '#991B1B'};
        padding: 1rem 1.5rem;
        border-radius: 0.5rem;
        margin-bottom: 0.5rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        animation: slideInNotification 0.3s ease;
        max-width: 400px;
    `;

    const icon = document.createElement('i');
    icon.className = `fas fa-${type === 'success' ? 'check-circle' : 'exclamation-circle'}`;

    const text = document.createElement('span');
    text.textContent = message;

    notification.appendChild(icon);
    notification.appendChild(text);
    container.appendChild(notification);

    // Supprimer la notification après 5 secondes
    setTimeout(() => {
        notification.style.animation = 'slideOutNotification 0.3s ease';
        setTimeout(() => notification.remove(), 300);
    }, 5000);
}

// Fonction pour basculer entre présent/absent
async function toggleAttendance(studentId) {
    const studentElement = document.getElementById(`student-${studentId}`);
    const currentStatus = studentElement.dataset.status;
    let newStatus;

    // Cycle: present -> absent -> present (ignorer late dans le cycle)
    if (currentStatus === 'present' || currentStatus === 'late') {
        newStatus = 'absent';
    } else {
        newStatus = 'present';
    }

    // Réinitialiser le champ de retard
    const lateInput = document.getElementById(`late-${studentId}`);
    lateInput.value = '';

    await updateAttendance(studentId, newStatus, null);
}

// Fonction pour marquer un élève en retard
async function setLateStatus(studentId) {
    const lateInput = document.getElementById(`late-${studentId}`);
    const minutes = lateInput.value;

    if (!minutes || minutes <= 0) {
        alert('Veuillez entrer le nombre de minutes de retard');
        lateInput.focus();
        return;
    }

    await updateAttendance(studentId, 'late', parseInt(minutes));
}

// Fonction pour envoyer la mise à jour au serveur
async function updateAttendance(studentId, status, lateMinutes) {
    try {
        const response = await fetch('{{ url_for("planning.update_attendance") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({
                student_id: studentId,
                classroom_id: classroomId,
                date: lessonDate,
                period_number: periodNumber,
                status: status,
                late_minutes: lateMinutes
            })
        });

        const result = await response.json();

        if (result.success) {
            // Mettre à jour l'interface
            const studentElement = document.getElementById(`student-${studentId}`);
            const lateInput = document.getElementById(`late-${studentId}`);

            // Retirer toutes les classes de statut
            studentElement.classList.remove('present', 'absent', 'late');

            // Ajouter la nouvelle classe
            studentElement.classList.add(status);
            studentElement.dataset.status = status;

            // Si ce n'est pas un retard, vider le champ
            if (status !== 'late') {
                lateInput.value = '';
            }

            // Mettre à jour les statistiques
            updateStats();

            // Afficher une notification visuelle
            showQuickNotification(studentElement, status);
        } else {
            alert('Erreur lors de la mise à jour de la présence');
        }
    } catch (error) {
        console.error('Erreur:', error);
        alert('Erreur lors de la communication avec le serveur');
    }
}

// Fonction pour afficher une notification rapide
function showQuickNotification(element, status) {
    element.style.transform = 'scale(0.95)';
    setTimeout(() => {
        element.style.transform = 'scale(1)';
    }, 200);
}

// Permettre d'entrer le retard avec Enter
document.addEventListener('DOMContentLoaded', function() {
    // Initialiser les contrôles de disposition
    initLayoutControls();
    
    // Initialiser les statistiques
    updateStats();

    // Ajouter l'événement Enter sur tous les champs de retard
    document.querySelectorAll('.late-minutes').forEach(input => {
        input.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                const studentId = this.id.replace('late-', '');
                setLateStatus(parseInt(studentId));
            }
        });
    });

    // Gérer les raccourcis clavier pour la planification
    document.addEventListener('keydown', function(e) {
        // Ctrl/Cmd + E pour éditer la planification
        if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
            e.preventDefault();
            if (!isEditingPlanning) {
                togglePlanningEdit();
            }
        }

        // Escape pour annuler l'édition
        if (e.key === 'Escape' && isEditingPlanning) {
            cancelPlanningEdit();
        }
    });
});

// Fonction pour mettre à jour les statistiques
function updateStats() {
    let present = 0;
    let absent = 0;
    let late = 0;

    document.querySelectorAll('.student-attendance').forEach(student => {
        const status = student.dataset.status;
        if (status === 'present') present++;
        else if (status === 'absent') absent++;
        else if (status === 'late') late++;
    });

    document.getElementById('presentCount').textContent = present;
    document.getElementById('absentCount').textContent = absent;
    document.getElementById('lateCount').textContent = late;
}

// Variables pour la gestion des ressources
let currentFolderPath = '';
let classResources = [];

// Charger les ressources de la classe au chargement de la page
document.addEventListener('DOMContentLoaded', function() {
    loadClassResources();
});

// Fonction pour charger les ressources de la classe
async function loadClassResources() {
    try {
        showResourcesLoading(true);
        
        const response = await fetch(`{{ url_for('planning.get_class_resources', classroom_id=0) }}`.replace('0', classroomId));
        const result = await response.json();
        
        if (result.success) {
            classResources = result.files || [];
            renderResources(result.pinned_files || [], classResources);
        } else {
            showNoResources();
        }
    } catch (error) {
        console.error('Erreur lors du chargement des ressources:', error);
        showNoResources();
    } finally {
        showResourcesLoading(false);
    }
}

// Fonction pour afficher/masquer le chargement
function showResourcesLoading(show) {
    const loadingElement = document.getElementById('resourcesLoading');
    if (loadingElement) {
        loadingElement.style.display = show ? 'block' : 'none';
    }
}

// Fonction pour afficher l'état vide
function showNoResources() {
    const noResourcesElement = document.getElementById('noResources');
    const pinnedElement = document.getElementById('pinnedResources');
    const navigationElement = document.getElementById('folderNavigation');
    const treeElement = document.getElementById('resourcesTree');
    
    if (noResourcesElement) noResourcesElement.style.display = 'block';
    if (pinnedElement) pinnedElement.style.display = 'none';
    if (navigationElement) navigationElement.style.display = 'none';
    if (treeElement) treeElement.style.display = 'none';
}

// Fonction pour rendre les ressources
function renderResources(pinnedFiles, allFiles) {
    const pinnedElement = document.getElementById('pinnedResources');
    const navigationElement = document.getElementById('folderNavigation');
    const treeElement = document.getElementById('resourcesTree');
    const noResourcesElement = document.getElementById('noResources');
    
    // Masquer l'état vide
    if (noResourcesElement) noResourcesElement.style.display = 'none';
    
    // Afficher les ressources épinglées
    if (pinnedFiles && pinnedFiles.length > 0) {
        renderPinnedResources(pinnedFiles);
        if (pinnedElement) pinnedElement.style.display = 'block';
    } else {
        if (pinnedElement) pinnedElement.style.display = 'none';
    }
    
    // À la racine, passer tous les fichiers à renderResourceTree pour qu'elle puisse extraire les dossiers
    // Dans un dossier spécifique, filtrer seulement les fichiers de ce dossier
    let filesToDisplay;
    if (!currentFolderPath) {
        // À la racine : passer tous les fichiers
        filesToDisplay = allFiles;
    } else {
        // Dans un dossier : filtrer
        filesToDisplay = filterFilesByFolder(allFiles, currentFolderPath);
    }
    
    // Afficher la navigation
    renderBreadcrumb();
    if (navigationElement) navigationElement.style.display = 'block';
    
    // Afficher l'arborescence
    renderResourceTree(filesToDisplay);
    if (treeElement) treeElement.style.display = 'block';
}

// Fonction pour rendre les ressources épinglées
function renderPinnedResources(pinnedFiles) {
    const pinnedList = document.getElementById('pinnedList');
    if (!pinnedList) return;
    
    pinnedList.innerHTML = pinnedFiles.map(file => {
        const isAnnotatable = ['pdf', 'png', 'jpg', 'jpeg'].includes(file.file_type.toLowerCase());
        
        return `
            <div class="resource-item pinned" data-file-id="${file.id}">
                <div class="resource-icon ${getResourceIconClass(file.file_type)}">
                    <i class="fas ${getResourceIcon(file.file_type)}"></i>
                </div>
                <div class="resource-info">
                    <div class="resource-main">
                        <div class="resource-name ${isAnnotatable ? 'clickable-file' : ''}" 
                             ${isAnnotatable ? `onclick="openFileViewer(${file.id}, '${file.original_filename}', '${file.file_type}')"` : ''}>
                            ${file.original_filename}
                        </div>
                        <div class="resource-meta">
                            <span>${formatFileSize(file.file_size)}</span>
                            <span>Épinglé</span>
                            ${isAnnotatable ? '<span class="annotatable-badge">✏️ Annotable</span>' : ''}
                        </div>
                    </div>
                    <div class="resource-actions">
                        <button class="resource-action-btn pinned" onclick="togglePinResource(${file.id})" title="Désépingler">
                            <i class="fas fa-thumbtack"></i>
                        </button>
                    </div>
                </div>
            </div>
        `;
    }).join('');
}

// Fonction pour filtrer les fichiers par dossier
function filterFilesByFolder(files, folderPath) {
    return files.filter(file => {
        if (!folderPath) {
            // Racine : fichiers sans dossier ou dossier vide
            return !file.folder_path || file.folder_path === '';
        } else {
            // Dossier spécifique : fichiers dans ce dossier exact OU dans ses sous-dossiers
            return file.folder_path === folderPath || 
                   (file.folder_path && file.folder_path.startsWith(folderPath + '/'));
        }
    });
}

// Fonction pour rendre le fil d'ariane
function renderBreadcrumb() {
    const breadcrumb = document.getElementById('resourceBreadcrumb');
    if (!breadcrumb) return;
    
    let html = `
        <span class="breadcrumb-item ${currentFolderPath === '' ? 'active' : ''}" 
              data-path="" onclick="navigateToFolder('')">
            <i class="fas fa-home"></i> Racine
        </span>
    `;
    
    if (currentFolderPath) {
        const pathParts = currentFolderPath.split('/');
        let currentPath = '';
        
        pathParts.forEach((part, index) => {
            currentPath += (index > 0 ? '/' : '') + part;
            const isLast = index === pathParts.length - 1;
            
            html += `
                <span class="breadcrumb-separator">/</span>
                <span class="breadcrumb-item ${isLast ? 'active' : ''}" 
                      data-path="${currentPath}" onclick="navigateToFolder('${currentPath}')">
                    ${part}
                </span>
            `;
        });
    }
    
    breadcrumb.innerHTML = html;
}

// Fonction pour rendre l'arborescence des ressources
function renderResourceTree(files) {
    const treeElement = document.getElementById('resourcesTree');
    if (!treeElement) return;
    
    // Organiser les fichiers par dossiers et fichiers
    const folders = new Set();
    const regularFiles = [];
    
    files.forEach(file => {
        if (file.folder_path) {
            if (!currentFolderPath) {
                // À la racine : extraire le premier niveau de dossier
                const topLevelFolder = file.folder_path.split('/')[0];
                folders.add(topLevelFolder);
            } else if (file.folder_path.startsWith(currentFolderPath + '/') || file.folder_path === currentFolderPath) {
                // Dans un dossier : vérifier si le fichier est exactement dans ce dossier ou dans un sous-dossier
                if (file.folder_path === currentFolderPath) {
                    // Fichier directement dans ce dossier
                    regularFiles.push(file);
                } else {
                    // Extraire le dossier suivant
                    const relativePath = file.folder_path.substring(currentFolderPath.length + 1);
                    const nextFolder = relativePath.split('/')[0];
                    if (nextFolder && nextFolder !== '') {
                        folders.add(nextFolder);
                    }
                }
            }
        } else {
            // Fichier sans dossier (directement à la racine)
            if (!currentFolderPath) {
                regularFiles.push(file);
            }
        }
    });
    
    let html = '';
    
    // Afficher les dossiers
    Array.from(folders).sort().forEach(folderName => {
        const folderPath = currentFolderPath ? `${currentFolderPath}/${folderName}` : folderName;
        html += `
            <div class="resource-item folder" onclick="navigateToFolder('${folderPath}')">
                <div class="resource-icon folder">
                    <i class="fas fa-folder"></i>
                </div>
                <div class="resource-info">
                    <div class="resource-main">
                        <div class="resource-name">${folderName}</div>
                        <div class="resource-meta">
                            <span>Dossier</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
    });
    
    // Afficher les fichiers
    regularFiles.forEach(file => {
        const isPinned = file.is_pinned;
        const isAnnotatable = ['pdf', 'png', 'jpg', 'jpeg'].includes(file.file_type.toLowerCase());
        
        html += `
            <div class="resource-item ${isPinned ? 'pinned' : ''}" data-file-id="${file.id}">
                <div class="resource-icon ${getResourceIconClass(file.file_type)}">
                    <i class="fas ${getResourceIcon(file.file_type)}"></i>
                </div>
                <div class="resource-info">
                    <div class="resource-main">
                        <div class="resource-name ${isAnnotatable ? 'clickable-file' : ''}" 
                             ${isAnnotatable ? `onclick="openFileViewer(${file.id}, '${file.original_filename}', '${file.file_type}')"` : ''}>
                            ${file.original_filename}
                        </div>
                        <div class="resource-meta">
                            <span>${formatFileSize(file.file_size)}</span>
                            ${file.uploaded_at ? `<span>${formatDate(file.uploaded_at)}</span>` : ''}
                            ${isAnnotatable ? '<span class="annotatable-badge">✏️ Annotable</span>' : ''}
                        </div>
                    </div>
                    <div class="resource-actions">
                        <button class="resource-action-btn ${isPinned ? 'pinned' : ''}" 
                                onclick="togglePinResource(${file.id})" 
                                title="${isPinned ? 'Désépingler' : 'Épingler'}">
                            <i class="fas fa-thumbtack"></i>
                        </button>
                    </div>
                </div>
            </div>
        `;
    });
    
    treeElement.innerHTML = html || '<p style="text-align: center; color: #6B7280; padding: 2rem;">Aucun fichier dans ce dossier</p>';
}

// Fonction pour naviguer vers un dossier
function navigateToFolder(folderPath) {
    currentFolderPath = folderPath;
    
    // Utiliser la même logique que dans renderResources
    let filesToDisplay;
    if (!currentFolderPath) {
        // À la racine : passer tous les fichiers
        filesToDisplay = classResources;
    } else {
        // Dans un dossier : filtrer
        filesToDisplay = filterFilesByFolder(classResources, currentFolderPath);
    }
    
    renderBreadcrumb();
    renderResourceTree(filesToDisplay);
}

// Fonction pour épingler/désépingler une ressource
async function togglePinResource(fileId) {
    try {
        const response = await fetch('{{ url_for("planning.toggle_pin_resource") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                file_id: fileId
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            // Recharger les ressources pour refléter les changements
            await loadClassResources();
        } else {
            console.error('Erreur lors de l\'épinglage:', result.message);
        }
    } catch (error) {
        console.error('Erreur lors de l\'épinglage:', error);
    }
}

// Fonction pour actualiser les ressources
function refreshResources() {
    loadClassResources();
}

// Fonctions utilitaires
function getResourceIcon(fileType) {
    switch(fileType) {
        case 'pdf': return 'fa-file-pdf';
        case 'png':
        case 'jpg':
        case 'jpeg': return 'fa-file-image';
        default: return 'fa-file';
    }
}

function getResourceIconClass(fileType) {
    switch(fileType) {
        case 'pdf': return 'pdf';
        case 'png':
        case 'jpg':
        case 'jpeg': return 'image';
        default: return '';
    }
}

function formatFileSize(bytes) {
    if (!bytes) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

function formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleDateString('fr-FR');
}

{% if is_current %}
// Gestion du timer
let timerInterval;
let isPaused = false;
let remainingSeconds = {{ remaining_seconds }};

function updateTimer() {
    if (!isPaused && remainingSeconds > 0) {
        remainingSeconds--;

        const hours = Math.floor(remainingSeconds / 3600);
        const minutes = Math.floor((remainingSeconds % 3600) / 60);
        const seconds = remainingSeconds % 60;

        let display = '';
        if (hours > 0) {
            display = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        } else {
            display = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        document.getElementById('lessonTimer').textContent = display;

        if (remainingSeconds === 0) {
            clearInterval(timerInterval);
            alert('Le cours est terminé !');
        }
    }
}

function toggleTimer() {
    isPaused = !isPaused;
    const icon = document.getElementById('timerIcon');
    icon.className = isPaused ? 'fas fa-play' : 'fas fa-pause';
}

// Démarrer le timer
timerInterval = setInterval(updateTimer, 1000);

// Nettoyer à la fermeture de la page
window.addEventListener('beforeunload', () => {
    clearInterval(timerInterval);
    
    // Sauvegarder les annotations si le viewer est ouvert
    if (currentFileId && annotations.length > 0) {
        // Utiliser sendBeacon pour une sauvegarde synchrone lors de la fermeture
        const data = JSON.stringify({
            file_id: currentFileId,
            annotations: annotations
        });
        
        // sendBeacon est plus fiable que fetch lors de beforeunload
        navigator.sendBeacon('/planning/save_file_annotations', new Blob([data], {type: 'application/json'}));
    }
});
{% endif %}

// =================== SYSTÈME D'ANNOTATION ===================

// Variables globales pour l'annotation améliorée
let currentFileId = null;
let currentAnnotationTool = 'pen';
let currentColor = '#000000';
let currentStrokeWidth = 3;
let isDrawing = false;
let isNavigating = false; // Nouveau: indique qu'on est en train de naviguer entre pages
let isLoadingInitialAnnotations = false; // Indique qu'on charge les annotations initiales
let annotations = []; // Annotations de la page actuelle (pour compatibilité)
let annotationsByPage = {}; // Nouveau: annotations organisées par numéro de page
let currentStroke = [];
let undoHistory = [];
let undoHistoryByPage = {}; // Historique d'annulation par page
let saveTimeout = null;

// Variables simplifiées

// Variables PDF
let pdfDoc = null;
let currentPageNum = 1;
let pageIsRendering = false;
let pageNumIsPending = null;
let currentScale = 1.0;
let pdfCanvas = null;
let pdfCtx = null;
let annotationCanvas = null;
let annotationCtx = null;
// Variables de compatibilité
let canvas = null;
let ctx = null;

// Charger PDF.js si pas déjà fait
if (typeof pdfjsLib === 'undefined') {
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
    script.onload = () => {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    };
    document.head.appendChild(script);
}

// Ouvrir le viewer de fichier amélioré
async function openFileViewer(fileId, filename, fileType) {
    currentFileId = fileId;
    
    // Réinitialiser les variables
    currentPageNum = 1;
    currentScale = 1.0;
    annotations = [];
    
    // Afficher le modal
    const modal = document.getElementById('fileViewerModal');
    modal.classList.add('show');
    
    // Initialiser les canvas
    initializeCanvases();
    
    // Charger le fichier et les annotations
    try {
        if (fileType.toLowerCase() === 'pdf') {
            await loadPDF(fileId);
            // Pour les PDF, charger les annotations après que la première page soit rendue
            await loadAnnotations(fileId);
        } else if (['png', 'jpg', 'jpeg'].includes(fileType.toLowerCase())) {
            await loadImage(fileId);
            // Pour les images, charger immédiatement
            await loadAnnotations(fileId);
        }
        
        setupAnnotationTools();
        
    } catch (error) {
        console.error('Erreur lors du chargement du fichier:', error);
        showError('Erreur lors du chargement du fichier');
    }
}

// Initialiser les canvas
function initializeCanvases() {
    pdfCanvas = document.getElementById('pdfCanvas');
    annotationCanvas = document.getElementById('annotationCanvas');
    
    if (pdfCanvas && annotationCanvas) {
        pdfCtx = pdfCanvas.getContext('2d');
        annotationCtx = annotationCanvas.getContext('2d');
        
        // Variables de compatibilité pour les autres fonctions
        canvas = annotationCanvas;
        ctx = annotationCtx;
        
        // Améliorer la qualité du rendu
        pdfCtx.imageSmoothingEnabled = true;
        pdfCtx.imageSmoothingQuality = 'high';
        annotationCtx.imageSmoothingEnabled = true;
        annotationCtx.imageSmoothingQuality = 'high';
        
        // Forcer le bon positionnement du canvas d'annotation
        forceCanvasPositioning();
    }
}

// Fonction pour forcer le bon positionnement du canvas
function forceCanvasPositioning() {
    if (!annotationCanvas || !pdfCanvas) return;
    
    console.log('🔧 Aligning annotation canvas with PDF canvas...');
    
    // Assurer que les canvas ont exactement les mêmes dimensions logiques
    annotationCanvas.width = pdfCanvas.width;
    annotationCanvas.height = pdfCanvas.height;
    
    // Obtenir les rectangles de position pour diagnostic
    const pdfRect = pdfCanvas.getBoundingClientRect();
    
    // Copier TOUS les styles computed du PDF canvas pour garantir un alignement parfait
    const pdfComputedStyle = window.getComputedStyle(pdfCanvas);
    
    // Assurer que les canvas ont exactement les mêmes styles CSS
    annotationCanvas.style.position = 'absolute';
    annotationCanvas.style.top = '0px';
    annotationCanvas.style.left = '0px';
    
    // IMPORTANT: Copier les dimensions exactement du PDF canvas
    // Les dimensions CSS doivent être les dimensions logiques (avant transformation)
    if (pdfCanvas.style.width) {
        annotationCanvas.style.width = pdfCanvas.style.width;
    } else {
        // Si pas de style explicite, utiliser les dimensions logiques
        annotationCanvas.style.width = pdfCanvas.width + 'px';
    }
    
    if (pdfCanvas.style.height) {
        annotationCanvas.style.height = pdfCanvas.style.height;
    } else {
        // Si pas de style explicite, utiliser les dimensions logiques
        annotationCanvas.style.height = pdfCanvas.height + 'px';
    }
    
    // Copier la transformation et l'origine exactement
    annotationCanvas.style.transform = pdfComputedStyle.transform;
    annotationCanvas.style.transformOrigin = pdfComputedStyle.transformOrigin;
    
    annotationCanvas.style.zIndex = '100'; // Au-dessus du PDF
    annotationCanvas.style.pointerEvents = 'auto';
    
    // S'assurer que le conteneur est configuré correctement
    const container = pdfCanvas.parentElement;
    if (container) {
        container.style.position = 'relative';
    }
    
    // Vérifier l'alignement après positionnement
    requestAnimationFrame(() => {
        const annotationRect = annotationCanvas.getBoundingClientRect();
        const pdfRectAfter = pdfCanvas.getBoundingClientRect();
        
        console.log('✅ Canvas alignment completed');
        console.log('  📏 PDF Canvas logical:', pdfCanvas.width, 'x', pdfCanvas.height);
        console.log('  📏 PDF Canvas visible:', Math.round(pdfRectAfter.width), 'x', Math.round(pdfRectAfter.height));
        console.log('  📏 Annotation Canvas logical:', annotationCanvas.width, 'x', annotationCanvas.height);
        console.log('  📏 Annotation Canvas visible:', Math.round(annotationRect.width), 'x', Math.round(annotationRect.height));
        console.log('  🎨 CSS width match:', annotationCanvas.style.width, '===', pdfCanvas.style.width || pdfComputedStyle.width);
        console.log('  🎨 CSS height match:', annotationCanvas.style.height, '===', pdfCanvas.style.height || pdfComputedStyle.height);
        console.log('  📍 Position alignment:', 
            Math.abs(pdfRectAfter.left - annotationRect.left) < 1 && Math.abs(pdfRectAfter.top - annotationRect.top) < 1);
        console.log('  📍 Size alignment:', 
            Math.abs(pdfRectAfter.width - annotationRect.width) < 1 && Math.abs(pdfRectAfter.height - annotationRect.height) < 1);
        console.log('  ⚖️  Scale factor X:', Math.round(annotationCanvas.width / annotationRect.width * 100) / 100);
        console.log('  ⚖️  Scale factor Y:', Math.round(annotationCanvas.height / annotationRect.height * 100) / 100);
        
        // Si les tailles ne correspondent pas, forcer la correction
        if (Math.abs(pdfRectAfter.width - annotationRect.width) > 1) {
            console.warn('⚠️  Size mismatch detected! Forcing correction...');
            annotationCanvas.style.width = pdfRectAfter.width + 'px';
            annotationCanvas.style.height = pdfRectAfter.height + 'px';
        }
        
        // 🔥 CRITIQUE: Redessiner les annotations après l'alignement car le redimensionnement les efface
        if (annotations.length > 0) {
            console.log('🎨 REDESSINAGE APRÈS ALIGNEMENT:', annotations.length, 'annotations');
            redrawAnnotations();
        }
    });
}

// Charger PDF.js de manière asynchrone
function loadPDFJS() {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
        script.onload = () => {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            resolve();
        };
        script.onerror = reject;
        document.head.appendChild(script);
    });
}

// Charger un PDF avec qualité améliorée
async function loadPDF(fileId) {
    const pdfUrl = `/file_manager/serve_file/${fileId}`;
    
    // Vérifier que PDF.js est chargé
    if (typeof pdfjsLib === 'undefined') {
        await loadPDFJS();
    }
    
    try {
        // Charger le PDF avec qualité améliorée
        const loadingTask = pdfjsLib.getDocument({
            url: pdfUrl,
            cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/cmaps/',
            cMapPacked: true,
            useSystemFonts: true
        });
        
        pdfDoc = await loadingTask.promise;
        console.log('PDF chargé, nombre de pages:', pdfDoc.numPages);
        
        // Mettre à jour l'interface
        updatePageInfo();
        updateNavigationButtons();
        
        // Générer les miniatures
        await generateThumbnails();
        
        // Rendre la première page
        await renderPage(currentPageNum);
        
    } catch (error) {
        console.error('Erreur lors du chargement du PDF:', error);
        throw error;
    }
}

// Rendre une page PDF
async function renderPage(pageNum) {
    if (pageIsRendering) {
        pageNumIsPending = pageNum;
        return;
    }
    
    // Ne pas rerender si on est en train de dessiner
    if (isDrawing) {
        console.log('renderPage delayed - currently drawing');
        pageNumIsPending = pageNum;
        return;
    }
    
    pageIsRendering = true;
    
    try {
        const page = await pdfDoc.getPage(pageNum);
        
        // Calculer la viewport avec une échelle plus élevée pour la qualité
        const baseScale = 2.0; // Base scale pour la qualité
        const displayScale = currentScale;
        const renderScale = baseScale * displayScale;
        
        const viewport = page.getViewport({ scale: renderScale });
        
        // Configurer les canvas
        pdfCanvas.width = viewport.width;
        pdfCanvas.height = viewport.height;
        
        // Ne redimensionner le canvas d'annotation que si nécessaire
        if (annotationCanvas.width !== viewport.width || annotationCanvas.height !== viewport.height) {
            console.log('📐 Resizing annotation canvas from', annotationCanvas.width, 'x', annotationCanvas.height, 'to', viewport.width, 'x', viewport.height);
            
            // Si on est en train de dessiner, arrêter le trait en cours
            if (isDrawing) {
                console.warn('⚠️ Canvas resize during drawing! Stopping current stroke...');
                isDrawing = false;
                currentStroke = [];
            }
            
            annotationCanvas.width = viewport.width;
            annotationCanvas.height = viewport.height;
            
            // Récréer le contexte après redimensionnement
            annotationCtx = annotationCanvas.getContext('2d');
            ctx = annotationCtx; // Variable de compatibilité
            
            // Forcer le repositionnement après redimensionnement
            forceCanvasPositioning();
        }
        
        // Appliquer le scale CSS pour l'affichage
        const cssScale = displayScale / baseScale;
        const transform = `scale(${cssScale})`;
        
        // D'abord définir les dimensions CSS explicites AVANT la transformation
        pdfCanvas.style.width = viewport.width + 'px';
        pdfCanvas.style.height = viewport.height + 'px';
        annotationCanvas.style.width = viewport.width + 'px';
        annotationCanvas.style.height = viewport.height + 'px';
        
        // Ensuite appliquer la transformation
        pdfCanvas.style.transform = transform;
        annotationCanvas.style.transform = transform;
        pdfCanvas.style.transformOrigin = '0 0';
        annotationCanvas.style.transformOrigin = '0 0';
        
        // Ajuster la taille du conteneur pour contenir les canvas transformés
        const container = pdfCanvas.parentElement;
        const containerWidth = viewport.width * cssScale;
        const containerHeight = viewport.height * cssScale;
        
        container.style.width = containerWidth + 'px';
        container.style.height = containerHeight + 'px';
        
        // Rendre la page
        const renderContext = {
            canvasContext: pdfCtx,
            viewport: viewport
        };
        
        await page.render(renderContext).promise;
        
        // Redessiner les annotations (seulement si on n'est pas en train de charger les annotations initiales)
        if (!isLoadingInitialAnnotations) {
            redrawAnnotations();
        } else {
            console.log('📄 Redessinage d\'annotations sauté - chargement initial en cours');
        }
        
        // Forcer l'alignement parfait des canvas après le rendu
        forceCanvasPositioning();
        
        pageIsRendering = false;
        
        // Rendre une page en attente si nécessaire
        if (pageNumIsPending !== null) {
            const pending = pageNumIsPending;
            pageNumIsPending = null;
            await renderPage(pending);
        }
        
    } catch (error) {
        console.error('Erreur lors du rendu de la page:', error);
        pageIsRendering = false;
    }
}

// Charger une image avec qualité améliorée
async function loadImage(fileId) {
    const imageUrl = `/file_manager/serve_file/${fileId}`;
    
    try {
        const img = new Image();
        await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = reject;
            img.src = imageUrl;
        });
        
        // Configurer les canvas pour l'image
        const scale = Math.min(800 / img.width, 600 / img.height, 2.0);
        const width = img.width * scale;
        const height = img.height * scale;
        
        pdfCanvas.width = width;
        pdfCanvas.height = height;
        annotationCanvas.width = width;
        annotationCanvas.height = height;
        
        // Dessiner l'image avec anti-aliasing
        pdfCtx.imageSmoothingEnabled = true;
        pdfCtx.imageSmoothingQuality = 'high';
        pdfCtx.drawImage(img, 0, 0, width, height);
        
        // Masquer les contrôles PDF
        document.getElementById('prevPageBtn').style.display = 'none';
        document.getElementById('nextPageBtn').style.display = 'none';
        document.getElementById('pageInfo').style.display = 'none';
        
    } catch (error) {
        console.error('Erreur lors du chargement de l\'image:', error);
        throw error;
    }
}

// ===== FONCTIONS DE NAVIGATION PDF =====

// Navigation entre pages
function previousPage() {
    if (currentPageNum <= 1 || !pdfDoc) return;
    if (isDrawing) {
        console.log('previousPage delayed - currently drawing');
        return;
    }
    
    isNavigating = true; // Marquer le début de la navigation
    
    // Sauvegarder les annotations de la page actuelle avant de changer
    console.log(`📄 Changement de page ${currentPageNum} vers ${currentPageNum - 1}`);
    saveCurrentPageAnnotations();
    
    currentPageNum--;
    
    // Charger les annotations de la nouvelle page AVANT de rendre
    loadPageAnnotations(currentPageNum);
    
    renderPage(currentPageNum);
    updatePageInfo();
    updateNavigationButtons();
    updateActiveThumbnail();
    
    isNavigating = false; // Marquer la fin de la navigation
}

function nextPage() {
    if (currentPageNum >= pdfDoc.numPages || !pdfDoc) return;
    if (isDrawing) {
        console.log('nextPage delayed - currently drawing');
        return;
    }
    
    isNavigating = true; // Marquer le début de la navigation
    
    // Sauvegarder les annotations de la page actuelle avant de changer
    console.log(`📄 Changement de page ${currentPageNum} vers ${currentPageNum + 1}`);
    saveCurrentPageAnnotations();
    
    currentPageNum++;
    
    // Charger les annotations de la nouvelle page AVANT de rendre
    loadPageAnnotations(currentPageNum);
    
    renderPage(currentPageNum);
    updatePageInfo();
    updateNavigationButtons();
    updateActiveThumbnail();
    
    isNavigating = false; // Marquer la fin de la navigation
}

function goToPage(pageNum) {
    if (pageNum < 1 || pageNum > pdfDoc.numPages) return;
    if (pageNum === currentPageNum) return; // Déjà sur cette page
    
    isNavigating = true; // Marquer le début de la navigation
    
    // Sauvegarder les annotations de la page actuelle avant de changer
    console.log(`📄 Navigation directe de la page ${currentPageNum} vers ${pageNum}`);
    saveCurrentPageAnnotations();
    
    currentPageNum = pageNum;
    
    // Charger les annotations de la nouvelle page AVANT de rendre
    loadPageAnnotations(currentPageNum);
    
    renderPage(currentPageNum);
    updatePageInfo();
    updateNavigationButtons();
    updateActiveThumbnail();
    
    isNavigating = false; // Marquer la fin de la navigation
}

// Fonction pour calculer les coordonnées du canvas - corrigée pour la scale CSS
function getCanvasCoordinates(e) {
    try {
        // Utiliser getBoundingClientRect pour obtenir la position et taille actuelles du canvas
        const rect = annotationCanvas.getBoundingClientRect();
        
        // Vérifier si la souris est au-dessus du canvas
        const isOverCanvas = (
            e.clientX >= rect.left && 
            e.clientX <= rect.right && 
            e.clientY >= rect.top && 
            e.clientY <= rect.bottom
        );
        
        // Calculer les coordonnées relatives au canvas visible
        // Important: utiliser rect.width/height (taille visible) plutôt que canvas.width/height (taille logique)
        const x = (e.clientX - rect.left) * (annotationCanvas.width / rect.width);
        const y = (e.clientY - rect.top) * (annotationCanvas.height / rect.height);
        
        // Debug temporaire pour vérifier les calculs
        if (Math.random() < 0.05) { // Log 5% des événements pour éviter le spam
            console.log('🔍 Coordinate calculation:');
            console.log('  Mouse screen:', e.clientX, e.clientY);
            console.log('  Canvas rect (visible):', Math.round(rect.left), Math.round(rect.top), Math.round(rect.width), Math.round(rect.height));
            console.log('  Canvas logical:', annotationCanvas.width, annotationCanvas.height);
            console.log('  Scale factors:', Math.round(annotationCanvas.width / rect.width * 100) / 100, Math.round(annotationCanvas.height / rect.height * 100) / 100);
            console.log('  Calculated coords:', Math.round(x), Math.round(y));
            console.log('  Within bounds:', x >= 0 && x <= annotationCanvas.width && y >= 0 && y <= annotationCanvas.height);
        }
        
        // Retourner les coordonnées, en s'assurant qu'elles restent dans les limites du canvas logique
        return { 
            x: Math.max(0, Math.min(x, annotationCanvas.width - 1)),
            y: Math.max(0, Math.min(y, annotationCanvas.height - 1)),
            isOverCanvas: isOverCanvas
        };
        
    } catch (error) {
        console.error('❌ Erreur dans getCanvasCoordinates:', error);
        
        // Retourner une coordonnée sûre en cas d'erreur
        return { x: 0, y: 0, isOverCanvas: false };
    }
}

// Fonctions de zoom supprimées - non utilisées

// Mettre à jour les informations de page
function updatePageInfo() {
    if (pdfDoc) {
        document.getElementById('pageInfo').textContent = `Page ${currentPageNum} / ${pdfDoc.numPages}`;
    }
}

function updateNavigationButtons() {
    if (!pdfDoc) return;
    
    document.getElementById('prevPageBtn').disabled = currentPageNum <= 1;
    document.getElementById('nextPageBtn').disabled = currentPageNum >= pdfDoc.numPages;
}

// Générer les miniatures
async function generateThumbnails() {
    if (!pdfDoc) return;
    
    const thumbnailsContainer = document.getElementById('pageThumbnails');
    thumbnailsContainer.innerHTML = '';
    
    for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
        const thumbnailItem = document.createElement('div');
        thumbnailItem.className = 'thumbnail-item';
        if (pageNum === currentPageNum) thumbnailItem.classList.add('active');
        
        const thumbnailCanvas = document.createElement('canvas');
        thumbnailCanvas.className = 'thumbnail-canvas';
        thumbnailCanvas.onclick = () => goToPage(pageNum);
        
        try {
            const page = await pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: 0.3 });
            
            thumbnailCanvas.width = viewport.width;
            thumbnailCanvas.height = viewport.height;
            
            const thumbnailCtx = thumbnailCanvas.getContext('2d');
            await page.render({
                canvasContext: thumbnailCtx,
                viewport: viewport
            }).promise;
            
        } catch (error) {
            console.error(`Erreur lors de la génération de la miniature ${pageNum}:`, error);
        }
        
        const pageLabel = document.createElement('div');
        pageLabel.textContent = pageNum;
        pageLabel.style.textAlign = 'center';
        pageLabel.style.color = '#e2e8f0';
        pageLabel.style.fontSize = '0.8rem';
        pageLabel.style.marginTop = '0.25rem';
        
        thumbnailItem.appendChild(thumbnailCanvas);
        thumbnailItem.appendChild(pageLabel);
        thumbnailsContainer.appendChild(thumbnailItem);
    }
}

function updateActiveThumbnail() {
    document.querySelectorAll('.thumbnail-item').forEach((item, index) => {
        item.classList.toggle('active', index + 1 === currentPageNum);
    });
}

// Barre latérale permanente - plus besoin de toggle

// ===== SYSTÈME D'ANNOTATION AMÉLIORÉ =====

// Système d'annotation amélioré
function setupAnnotationTools() {
    if (!annotationCanvas) {
        console.error('annotationCanvas not found!');
        return;
    }
    
    console.log('Setting up annotation tools on canvas:', annotationCanvas);
    
    // Debug des styles CSS
    const computedStyle = window.getComputedStyle(annotationCanvas);
    console.log('Canvas CSS styles:');
    console.log('  pointer-events:', computedStyle.pointerEvents);
    console.log('  z-index:', computedStyle.zIndex);
    console.log('  position:', computedStyle.position);
    console.log('  display:', computedStyle.display);
    console.log('  visibility:', computedStyle.visibility);
    
    // Événements de dessin simplifiés
    console.log('Attaching mousedown event listener...');
    annotationCanvas.addEventListener('mousedown', (e) => {
        console.log('🔽 MOUSEDOWN EVENT');
        startDrawing(e);
    });
    
    console.log('Attaching mousemove event listener to DOCUMENT (for global coverage)...');
    document.addEventListener('mousemove', (e) => {
        if (isDrawing) {
            draw(e);
        }
    });
    
    console.log('Attaching mouseup event listener to DOCUMENT (for global coverage)...');
    document.addEventListener('mouseup', (e) => {
        console.log('🔼 MOUSEUP EVENT');
        stopDrawing(e);
    });
    
    console.log('Attaching mouseout event listener (for debugging only)...');
    annotationCanvas.addEventListener('mouseout', (e) => {
        console.log('🚪 MOUSEOUT EVENT (ignored)');
        // NE PAS appeler stopDrawing() ici - l'utilisateur doit pouvoir dessiner hors du canvas
    });
    
    // Support tactile
    annotationCanvas.addEventListener('touchstart', handleTouch, { passive: false });
    annotationCanvas.addEventListener('touchmove', handleTouch, { passive: false });
    annotationCanvas.addEventListener('touchend', handleTouch, { passive: false });
    
    console.log('Event listeners attached successfully');
    
    // Test de débogage AMÉLIORÉ : vérifier quel élément reçoit les clics
    document.addEventListener('mousedown', (e) => {
        if (!annotationCanvas) return;
        
        // Vérifier si le clic est sur un élément d'interface (à exclure de l'interception)
        const isUIElement = e.target.matches('input, button, select, textarea, .tool-btn, .color-btn, .stroke-width-container, .stroke-width-container *, .annotation-toolbar, .annotation-toolbar *');
        
        if (isUIElement) {
            console.log('🎛️ Click on UI element, allowing normal behavior:', e.target);
            return; // Laisser le comportement normal pour les éléments d'interface
        }
        
        const rect = annotationCanvas.getBoundingClientRect();
        const isOverCanvas = e.clientX >= rect.left && e.clientX <= rect.right && 
                           e.clientY >= rect.top && e.clientY <= rect.bottom;
        
        if (isOverCanvas) {
            console.log('🎯 CLICK ANALYSIS:');
            console.log('  📍 Mouse position:', e.clientX, e.clientY);
            console.log('  📦 Canvas bounds:', rect);
            console.log('  🎯 Target element:', e.target);
            console.log('  ❓ Is annotation canvas?', e.target === annotationCanvas);
            console.log('  🔍 Element at point:', document.elementFromPoint(e.clientX, e.clientY));
            console.log('  📊 Target classes:', e.target.className);
            console.log('  🏷️ Target ID:', e.target.id);
            console.log('  🌳 Target parent:', e.target.parentElement);
            
            // CSS debugging
            const targetStyle = window.getComputedStyle(e.target);
            console.log('  🎨 Target z-index:', targetStyle.zIndex);
            console.log('  👆 Target pointer-events:', targetStyle.pointerEvents);
            console.log('  📐 Target position:', targetStyle.position);
            
            const canvasStyle = window.getComputedStyle(annotationCanvas);
            console.log('  🎨 Canvas z-index:', canvasStyle.zIndex);
            console.log('  👆 Canvas pointer-events:', canvasStyle.pointerEvents);
            
            console.log('🎯 Click intercepted and will be redirected to canvas');
            
            // Si le clic n'est pas directement sur le canvas, forcer l'événement
            if (e.target !== annotationCanvas) {
                console.log('🔄 FORCING click to annotation canvas...');
                e.preventDefault();
                e.stopPropagation();
                
                const canvasEvent = new MouseEvent('mousedown', {
                    clientX: e.clientX,
                    clientY: e.clientY,
                    button: e.button,
                    buttons: e.buttons,
                    bubbles: true
                });
                annotationCanvas.dispatchEvent(canvasEvent);
            }
        }
    }, true); // Utiliser capture phase pour intercepter tôt
    
    // Démarrer le monitoring
    // Monitoring désactivé pour simplifier
    
    // Détecteurs de clics globaux supprimés pour simplifier
    
    // Événements des outils
    setupToolEvents();
}

// Fonctions de diagnostic supprimées pour simplifier le code

function setupToolEvents() {
    // Outils de dessin
    document.querySelectorAll('[data-tool]').forEach(btn => {
        btn.addEventListener('click', () => setAnnotationTool(btn.dataset.tool));
    });
    
    // Couleurs
    document.querySelectorAll('.color-btn').forEach(btn => {
        btn.addEventListener('click', () => setAnnotationColor(btn.dataset.color));
    });
    
    document.getElementById('annotationColor').addEventListener('change', (e) => {
        setAnnotationColor(e.target.value);
    });
    
    // Épaisseur
    const strokeWidthSlider = document.getElementById('strokeWidth');
    const strokeWidthValue = document.getElementById('strokeWidthValue');
    
    if (strokeWidthSlider) {
        console.log('📏 Stroke width slider found:', strokeWidthSlider);
        console.log('📏 Initial value:', strokeWidthSlider.value);
        console.log('📏 Min:', strokeWidthSlider.min, 'Max:', strokeWidthSlider.max);
        console.log('📏 Disabled:', strokeWidthSlider.disabled);
        
        strokeWidthSlider.addEventListener('input', (e) => {
            currentStrokeWidth = parseInt(e.target.value);
            strokeWidthValue.textContent = currentStrokeWidth;
            console.log('🎨 Stroke width changed to:', currentStrokeWidth);
        });
        
        // Ajouter aussi l'événement 'change' pour les navigateurs qui ne supportent pas bien 'input'
        strokeWidthSlider.addEventListener('change', (e) => {
            currentStrokeWidth = parseInt(e.target.value);
            strokeWidthValue.textContent = currentStrokeWidth;
            console.log('🎨 Stroke width changed to (change event):', currentStrokeWidth);
        });
        
        // Test si le curseur est accessible
        strokeWidthSlider.addEventListener('mousedown', (e) => {
            console.log('🖱️ Mouse down on slider');
        });
        
        strokeWidthSlider.addEventListener('click', (e) => {
            console.log('🖱️ Click on slider at position:', e.offsetX);
        });
    } else {
        console.error('❌ Stroke width slider not found!');
    }
    
    // Actions
    document.getElementById('undoBtn').addEventListener('click', undo);
    document.getElementById('clearAllBtn').addEventListener('click', clearAll);
}

// Changer d'outil d'annotation
function setAnnotationTool(tool) {
    currentAnnotationTool = tool;
    
    // Mettre à jour l'interface
    document.querySelectorAll('[data-tool]').forEach(btn => {
        btn.classList.remove('active');
    });
    
    document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
    
    // Changer le curseur
    if (annotationCanvas) {
        annotationCanvas.style.cursor = tool === 'eraser' ? 'grab' : 'crosshair';
    }
}

// Changer de couleur
function setAnnotationColor(color) {
    currentColor = color;
    
    // Mettre à jour l'interface
    document.querySelectorAll('.color-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    const colorBtn = document.querySelector(`[data-color="${color}"]`);
    if (colorBtn) {
        colorBtn.classList.add('active');
    }
    
    document.getElementById('annotationColor').value = color;
}

// Fonction de dessin simple - basée sur la logique de la gomme qui fonctionne
function startDrawing(e) {
    if (!annotationCtx || !annotationCanvas) {
        console.error('❌ Canvas ou contexte indisponible');
        return;
    }
    
    isDrawing = true;
    currentStroke = [];
    
    console.log('🎨 Début du dessin avec outil:', currentAnnotationTool);
    
    const coords = getCanvasCoordinates(e);
    currentStroke.push(coords);
    
    if (currentAnnotationTool === 'eraser') {
        eraseAt(coords.x, coords.y);
    } else {
        // Pour le stylo : commencer un nouveau path
        drawAt(coords.x, coords.y, true); // true = début de trait
    }
}

// Fonction de dessin simplifiée
function draw(e) {
    if (!isDrawing) return;
    
    const coords = getCanvasCoordinates(e);
    currentStroke.push(coords);
    
    if (currentAnnotationTool === 'eraser') {
        eraseAt(coords.x, coords.y);
    } else {
        // Pour le stylo : continuer le trait
        drawAt(coords.x, coords.y, false); // false = continuation de trait
    }
}

// Fonction d'arrêt simplifiée
function stopDrawing() {
    if (!isDrawing) return;
    
    console.log('🛑 Arrêt du dessin');
    isDrawing = false;
    
    // Finaliser le dessin (pour restaurer le contexte)
    if (currentAnnotationTool !== 'eraser') {
        annotationCtx.restore();
    }
    
    // Sauvegarder l'annotation si ce n'est pas la gomme
    if (currentStroke.length > 0 && currentAnnotationTool !== 'eraser') {
        const annotation = {
            type: currentAnnotationTool,
            color: currentColor,
            strokeWidth: currentStrokeWidth,
            points: [...currentStroke],
            page: currentPageNum,
            scale: currentScale,
            timestamp: Date.now()
        };
        
        annotations.push(annotation);
        undoHistory.push(annotations.length - 1);
    }
    
    currentStroke = [];
}

// Fonction de dessin simple - inspirée d'eraseAt qui fonctionne bien
function drawAt(x, y, isStart) {
    if (isStart) {
        // Configurer le style pour ce trait
        annotationCtx.save();
        
        if (currentAnnotationTool === 'pen') {
            annotationCtx.globalCompositeOperation = 'source-over';
            annotationCtx.strokeStyle = currentColor;
            annotationCtx.lineWidth = currentStrokeWidth * (currentScale || 1);
            annotationCtx.lineCap = 'round';
            annotationCtx.lineJoin = 'round';
            annotationCtx.globalAlpha = 1.0;
        } else if (currentAnnotationTool === 'highlighter') {
            annotationCtx.globalCompositeOperation = 'multiply';
            annotationCtx.strokeStyle = currentColor;
            annotationCtx.lineWidth = currentStrokeWidth * 3 * (currentScale || 1);
            annotationCtx.lineCap = 'round';
            annotationCtx.lineJoin = 'round';
            annotationCtx.globalAlpha = 0.3;
        }
        
        // Commencer un nouveau path
        annotationCtx.beginPath();
        annotationCtx.moveTo(x, y);
    } else {
        // Continuer le trait
        annotationCtx.lineTo(x, y);
        annotationCtx.stroke();
    }
}

// Fonction d'effacement améliorée
function eraseAt(x, y) {
    const eraseRadius = currentStrokeWidth * 3 * (currentScale || 1);
    
    // Effacer dans un rayon autour du point
    annotationCtx.save();
    annotationCtx.globalCompositeOperation = 'destination-out';
    annotationCtx.beginPath();
    annotationCtx.arc(x, y, eraseRadius, 0, 2 * Math.PI);
    annotationCtx.fill();
    annotationCtx.restore();
    
    // Marquer les annotations comme effacées dans cette zone
    annotations.forEach(annotation => {
        if (annotation.page && annotation.page !== currentPageNum) return;
        
        annotation.points = annotation.points.filter(point => {
            const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
            return distance > eraseRadius;
        });
    });
    
    // Supprimer les annotations vides
    annotations = annotations.filter(annotation => annotation.points.length > 0);
    
    // Sauvegarde désactivée pendant le dessin pour éviter les blocages
    // scheduleAutoSave();
}

// Fonction stopDrawing supprimée - doublon

// Gestion tactile améliorée
function handleTouch(e) {
    e.preventDefault();
    
    if (e.touches.length === 1) {
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent(
            e.type === 'touchstart' ? 'mousedown' : 
            e.type === 'touchmove' ? 'mousemove' : 'mouseup', 
            {
                clientX: touch.clientX,
                clientY: touch.clientY
            }
        );
        
        annotationCanvas.dispatchEvent(mouseEvent);
    }
}

// Redessiner les annotations
function redrawAnnotations() {
    if (!annotationCtx) {
        console.warn('⚠️ redrawAnnotations: annotationCtx not available');
        return;
    }
    
    // Ne pas redessiner si on est en train de dessiner pour éviter d'effacer le trait en cours
    if (isDrawing) {
        console.log('redrawAnnotations skipped - currently drawing');
        return;
    }
    
    console.log(`📄 redrawAnnotations called for page ${currentPageNum} with ${annotations.length} annotations:`, annotations);
    
    // Effacer le canvas
    annotationCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
    
    // Compter les annotations qui seront dessinées
    let drawnCount = 0;
    
    annotations.forEach((annotation, index) => {
        if (!annotation || !annotation.points || annotation.points.length === 0) {
            console.log(`❌ Annotation ${index} skipped - no points:`, annotation);
            return;
        }
        
        // Double vérification pour détecter d'éventuels problèmes de filtrage
        if (annotation.page && annotation.page !== currentPageNum) {
            console.error(`🚨 BUG DÉTECTÉ: Annotation ${index} de la page ${annotation.page} trouvée dans le tableau de la page ${currentPageNum}!`, annotation);
            return;
        }
        
        console.log(`✏️ Drawing annotation ${index}:`, {
            type: annotation.type,
            color: annotation.color,
            strokeWidth: annotation.strokeWidth,
            pointsCount: annotation.points.length,
            page: annotation.page
        });
        
        annotationCtx.beginPath();
        annotationCtx.moveTo(annotation.points[0].x, annotation.points[0].y);
        
        // Configurer le style
        if (annotation.type === 'pen') {
            annotationCtx.globalCompositeOperation = 'source-over';
            annotationCtx.strokeStyle = annotation.color;
            annotationCtx.lineWidth = annotation.strokeWidth * (currentScale || 1);
            annotationCtx.lineCap = 'round';
            annotationCtx.lineJoin = 'round';
            annotationCtx.globalAlpha = 1.0;
        } else if (annotation.type === 'highlighter') {
            annotationCtx.globalCompositeOperation = 'multiply';
            annotationCtx.strokeStyle = annotation.color;
            annotationCtx.lineWidth = annotation.strokeWidth * 3 * (currentScale || 1);
            annotationCtx.lineCap = 'round';
            annotationCtx.lineJoin = 'round';
            annotationCtx.globalAlpha = 0.3;
        }
        
        // Dessiner le trait
        for (let i = 1; i < annotation.points.length; i++) {
            annotationCtx.lineTo(annotation.points[i].x, annotation.points[i].y);
        }
        
        annotationCtx.stroke();
        
        if (annotation.type === 'highlighter') {
            annotationCtx.globalAlpha = 1.0;
        }
        
        drawnCount++;
    });
    
    console.log(`✅ redrawAnnotations completed: ${drawnCount}/${annotations.length} annotations drawn on page ${currentPageNum}`);
}

// Charger les annotations
async function loadAnnotations(fileId) {
    try {
        isLoadingInitialAnnotations = true;
        console.log('📄 Chargement des annotations depuis le serveur...');
        const response = await fetch(`/planning/get_file_annotations/${fileId}`);
        const result = await response.json();
        
        if (result.success) {
            // Utiliser le nouveau système pour charger toutes les annotations
            loadAllAnnotations(result.annotations);
            console.log('📄 Annotations chargées avec succès depuis le serveur');
        } else {
            console.log('📄 Aucune annotation trouvée sur le serveur - démarrage avec document vierge');
            loadAllAnnotations({});
        }
    } catch (error) {
        console.error('Erreur lors du chargement des annotations:', error);
        loadAllAnnotations({});
    } finally {
        isLoadingInitialAnnotations = false;
    }
}

// Annuler la dernière action
function undo() {
    if (annotations.length > 0) {
        // Annuler uniquement sur la page actuelle
        annotations.pop(); // Supprimer la dernière annotation
        redrawAnnotations();
        console.log(`↩️ Annulation effectuée sur la page ${currentPageNum}, ${annotations.length} annotations restantes`);
        // Les annotations seront sauvegardées automatiquement lors du changement de page
    }
}

// Tout effacer
function clearAll() {
    if (confirm('Êtes-vous sûr de vouloir effacer toutes les annotations de cette page ?')) {
        const removedCount = annotations.length;
        annotations = []; // Vider toutes les annotations de la page actuelle
        undoHistory = []; // Vider l'historique aussi
        redrawAnnotations();
        console.log(`🗑️ ${removedCount} annotations supprimées de la page ${currentPageNum}`);
        // Les changements seront sauvegardés automatiquement lors du changement de page
    }
}

// === GESTION DES ANNOTATIONS PAR PAGE ===

// Sauvegarder les annotations de la page actuelle dans la structure par page
function saveCurrentPageAnnotations() {
    if (!currentPageNum) return;
    
    // FILTRER les annotations pour ne sauvegarder que celles de la page actuelle
    const pageAnnotations = annotations.filter(annotation => {
        // Inclure les annotations sans page définie (legacy) ou celles de la page actuelle
        return !annotation.page || annotation.page === currentPageNum;
    });
    
    if (pageAnnotations.length > 0) {
        annotationsByPage[currentPageNum] = [...pageAnnotations]; // Copie du tableau FILTRÉ
        console.log(`📄 ${pageAnnotations.length} annotations sauvegardées pour la page ${currentPageNum}:`, pageAnnotations);
    } else {
        // Si aucune annotation, supprimer la page de la structure (économise l'espace)
        if (annotationsByPage[currentPageNum]) {
            delete annotationsByPage[currentPageNum];
            console.log(`📄 Page ${currentPageNum} supprimée (aucune annotation)`);
        }
    }
    
    // Sauvegarder aussi l'historique d'annulation
    if (undoHistory.length > 0) {
        undoHistoryByPage[currentPageNum] = [...undoHistory];
    } else {
        // Nettoyer l'historique vide
        if (undoHistoryByPage[currentPageNum]) {
            delete undoHistoryByPage[currentPageNum];
        }
    }
}

// Charger les annotations d'une page spécifique
function loadPageAnnotations(pageNum) {
    console.log(`📄 Chargement des annotations pour la page ${pageNum}`);
    console.log(`📄 Annotations disponibles par page:`, Object.keys(annotationsByPage));
    
    // Charger les annotations de cette page
    if (annotationsByPage[pageNum]) {
        const rawAnnotations = [...annotationsByPage[pageNum]]; // Copie du tableau
        
        // DOUBLE FILTRAGE pour s'assurer qu'on n'a que les annotations de cette page
        annotations = rawAnnotations.filter(annotation => {
            // Inclure les annotations sans page définie (legacy) ou celles de cette page
            return !annotation.page || annotation.page === pageNum;
        });
        
        if (rawAnnotations.length !== annotations.length) {
            console.warn(`⚠️ NETTOYAGE: ${rawAnnotations.length - annotations.length} annotations d'autres pages supprimées`);
        }
        
        console.log(`✅ ${annotations.length} annotations chargées pour la page ${pageNum}:`, annotations);
    } else {
        annotations = [];
        console.log(`📄 Aucune annotation trouvée pour la page ${pageNum} - page vierge`);
    }
    
    // Charger l'historique d'annulation
    if (undoHistoryByPage[pageNum]) {
        undoHistory = [...undoHistoryByPage[pageNum]];
    } else {
        undoHistory = [];
    }
    
    // Redessiner les annotations sur le canvas (forcé)
    console.log(`📄 Redessinage forcé des annotations pour la page ${pageNum}`);
    if (annotationCtx) {
        redrawAnnotations();
    } else {
        console.warn('⚠️ annotationCtx non disponible pour redessiner');
    }
}

// Obtenir toutes les annotations de toutes les pages pour la sauvegarde
function getAllAnnotations() {
    // D'abord sauvegarder la page actuelle
    saveCurrentPageAnnotations();
    
    // Retourner toutes les annotations organisées par page
    return annotationsByPage;
}

// Charger toutes les annotations depuis les données sauvegardées
function loadAllAnnotations(savedAnnotations) {
    console.log('📄 Chargement de toutes les annotations:', savedAnnotations);
    
    if (savedAnnotations && typeof savedAnnotations === 'object' && !Array.isArray(savedAnnotations)) {
        // Nouveau format par page
        annotationsByPage = savedAnnotations;
        console.log(`📄 ${Object.keys(annotationsByPage).length} pages avec annotations trouvées`);
        
        // Charger les annotations de la page actuelle
        loadPageAnnotations(currentPageNum);
    } else if (Array.isArray(savedAnnotations)) {
        // Ancien format (compatibility) - toutes les annotations sur la page 1
        console.log('📄 Format legacy détecté - migration vers format par page');
        annotationsByPage = {};
        if (savedAnnotations.length > 0) {
            annotationsByPage[1] = savedAnnotations;
        }
        loadPageAnnotations(currentPageNum);
    } else {
        // Aucune annotation ou format non reconnu
        console.log('📄 Aucune annotation ou format non reconnu - démarrage vierge');
        annotationsByPage = {};
        annotations = [];
        undoHistory = [];
        // S'assurer que le canvas est nettoyé
        if (annotationCtx) {
            redrawAnnotations();
        }
    }
    
    console.log(`📄 Fin du chargement - page actuelle ${currentPageNum} avec ${annotations.length} annotations`);
}

// Fonction scheduleAutoSave supprimée - sauvegarde uniquement à la fermeture

// Sauvegarder les annotations (appelé uniquement à la fermeture)
async function saveAnnotations() {
    if (!currentFileId) return;
    
    // Indicateur visuel
    const saveStatus = document.getElementById('saveStatus');
    if (saveStatus) {
        saveStatus.className = 'save-status saving';
        saveStatus.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Sauvegarde...';
    }
    
    try {
        // Utiliser le nouveau système : obtenir toutes les annotations de toutes les pages
        const allAnnotations = getAllAnnotations();
        
        console.log('💾 Sauvegarde de toutes les annotations:', allAnnotations);
        
        const response = await fetch('/planning/save_file_annotations', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({
                file_id: currentFileId,
                annotations: allAnnotations // Maintenant c'est un objet avec les pages
            })
        });
        
        const result = await response.json();
        const saveStatus = document.getElementById('saveStatus');
        
        if (result.success) {
            if (saveStatus) {
                saveStatus.className = 'save-status';
                saveStatus.innerHTML = '<i class="fas fa-check"></i> Annotations sauvegardées';
            }
            console.log('💾 Annotations sauvegardées avec succès pour toutes les pages');
        } else {
            if (saveStatus) {
                saveStatus.className = 'save-status error';
                saveStatus.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Erreur de sauvegarde';
            }
            console.error('Erreur de sauvegarde:', result.message);
        }
    } catch (error) {
        console.error('Erreur lors de la sauvegarde:', error);
        if (saveStatus) {
            saveStatus.className = 'save-status error';
            saveStatus.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Erreur de connexion';
        }
    }
}

// Afficher une erreur
function showError(message) {
    const container = document.getElementById('viewerContainer');
    container.innerHTML = `
        <div style="text-align: center; padding: 2rem; color: #FC8181;">
            <i class="fas fa-exclamation-triangle fa-2x"></i>
            <p>${message}</p>
            <button onclick="closeFileViewer()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #4F46E5; color: white; border: none; border-radius: 0.5rem; cursor: pointer;">
                Fermer
            </button>
        </div>
    `;
}

// Charger le contenu du fichier
async function loadFileContent(fileId, fileType, container) {
    container.innerHTML = '<div style="text-align: center; padding: 2rem;"><i class="fas fa-spinner fa-spin fa-2x"></i><p>Chargement...</p></div>';
    
    console.log('Chargement du fichier:', {fileId, fileType});
    
    try {
        if (fileType.toLowerCase() === 'pdf') {
            await loadPDF(fileId, container);
        } else if (['png', 'jpg', 'jpeg'].includes(fileType.toLowerCase())) {
            await loadImage(fileId, container);
        }
        console.log('Fichier chargé avec succès');
    } catch (error) {
        console.error('Erreur détaillée lors du chargement:', error);
        container.innerHTML = `
            <div style="color: #FC8181; text-align: center; padding: 2rem;">
                <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                <h3>Erreur lors du chargement du fichier</h3>
                <p style="margin-top: 1rem; font-size: 0.9rem;">${error.message}</p>
                <button onclick="closeFileViewer()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #4F46E5; color: white; border: none; border-radius: 0.5rem; cursor: pointer;">
                    Fermer
                </button>
            </div>
        `;
    }
}


// Charger une image
async function loadImage(fileId, container) {
    try {
        const img = document.createElement('img');
        img.src = `/file_manager/serve_file/${fileId}`;
        
        // Ajouter un timeout pour éviter l'attente infinie
        const loadTimeout = setTimeout(() => {
            throw new Error('Timeout: L\'image prend trop de temps à charger');
        }, 10000);
        
        img.onload = () => {
            clearTimeout(loadTimeout);
            
            // Créer le conteneur
            const imageContainer = document.createElement('div');
            imageContainer.className = 'image-container';
            
            // Ajuster la taille de l'image pour qu'elle s'adapte à l'écran
            const maxWidth = window.innerWidth * 0.8;
            const maxHeight = window.innerHeight * 0.6;
            
            let { width, height } = img;
            
            if (width > maxWidth) {
                height = (height * maxWidth) / width;
                width = maxWidth;
            }
            
            if (height > maxHeight) {
                width = (width * maxHeight) / height;
                height = maxHeight;
            }
            
            img.style.width = width + 'px';
            img.style.height = height + 'px';
            
            imageContainer.appendChild(img);
            
            // Créer le canvas d'annotation
            canvas = document.createElement('canvas');
            canvas.className = 'annotation-canvas';
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx = canvas.getContext('2d');
            
            imageContainer.appendChild(canvas);
            container.innerHTML = '';
            container.appendChild(imageContainer);
        };
        
        img.onerror = () => {
            clearTimeout(loadTimeout);
            throw new Error('Impossible de charger l\'image');
        };
        
    } catch (error) {
        console.error('Erreur lors du chargement de l\'image:', error);
        throw error;
    }
}

// Fonction loadAnnotations dupliquée supprimée - utiliser celle définie plus haut avec le système par page

// Code orphelin supprimé - déjà géré dans setupToolEvents()

// Fonctions de dessin supprimées - dupliquées avec celles qui utilisent annotationCanvas

// Fonctions dupliquées supprimées - déjà définies plus haut dans le fichier

// Fonction saveAnnotations dupliquée supprimée - déjà définie plus haut

// Fermer le viewer amélioré
function closeFileViewer() {
    try {
        // Sauvegarder les annotations de la page actuelle avant de fermer
        console.log('📄 Fermeture du viewer - sauvegarde des annotations de la page actuelle...');
        saveCurrentPageAnnotations();
        
        // Sauvegarder toutes les annotations
        if (Object.keys(annotationsByPage).length > 0 || annotations.length > 0) {
            saveAnnotations();
        }
        
        const modal = document.getElementById('fileViewerModal');
        if (modal) {
            modal.classList.remove('show');
        }
        
        // Nettoyer les variables
        currentFileId = null;
        annotations = [];
        annotationsByPage = {}; // Nettoyer les annotations par page
        undoHistoryByPage = {}; // Nettoyer l'historique par page
        pdfDoc = null;
        currentPageNum = 1;
        currentScale = 1.0;
        pdfCanvas = null;
        pdfCtx = null;
        annotationCanvas = null;
        annotationCtx = null;
        
        if (saveTimeout) {
            clearTimeout(saveTimeout);
            saveTimeout = null;
        }
        
        // Masquer la barre latérale
        document.getElementById('pageSidebar').classList.remove('show');
        
    } catch (error) {
        console.error('Erreur lors de la fermeture:', error);
        const modal = document.getElementById('fileViewerModal');
        if (modal) {
            modal.style.display = 'none';
        }
    }
}

// Événements globaux améliorés
document.addEventListener('keydown', (e) => {
    const modal = document.getElementById('fileViewerModal');
    if (!modal.classList.contains('show')) return;
    
    if (e.key === 'Escape') {
        closeFileViewer();
    } else if (e.key === 'ArrowLeft') {
        e.preventDefault();
        previousPage();
    } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        nextPage();
    // Raccourcis zoom supprimés
    }
});

document.addEventListener('click', (e) => {
    const modal = document.getElementById('fileViewerModal');
    if (e.target === modal && modal.classList.contains('show')) {
        closeFileViewer();
    }
});

// Fonctions pour la gestion des onglets de suivi
function showTrackingTab(tabName) {
    // Désactiver tous les onglets
    document.querySelectorAll('.tracking-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // Masquer tous les contenus
    document.querySelectorAll('.tracking-content').forEach(content => {
        content.classList.remove('active');
    });
    
    // Activer l'onglet cliqué
    event.target.closest('.tracking-tab').classList.add('active');
    
    // Afficher le contenu correspondant
    document.getElementById(tabName + '-content').classList.add('active');
    
    // Si c'est l'onglet plan de classe, charger le plan
    if (tabName === 'seating-plan') {
        setTimeout(() => {
            loadSeatingPlan();
        }, 100);
    }
}

// Fonctions pour l'initialisation du système de sanctions
function initializeSanctionSystem() {
    // Stocker les compteurs initiaux au début de la période
    document.querySelectorAll('.count-display').forEach(element => {
        const studentId = element.getAttribute('data-student');
        const sanctionId = element.getAttribute('data-sanction');
        const count = parseInt(element.textContent) || 0;
        initialSanctionCounts[`${studentId}_${sanctionId}`] = count;
    });
    
    // Démarrer la surveillance uniquement si on est en cours actuel
    {% if is_current and remaining_seconds > 0 %}
    startSanctionMonitoring();
    {% endif %}
}

function startSanctionMonitoring() {
    // Vérifier 3 minutes avant la fin
    const timeToNotification = {{ remaining_seconds * 1000 }} - NOTIFICATION_TIME_BEFORE_END;
    
    if (timeToNotification > 0) {
        sanctionCheckTimer = setTimeout(() => {
            checkForSanctionThresholds();
        }, timeToNotification);
        
        console.log(`Surveillance des sanctions activée. Vérification dans ${Math.round(timeToNotification / 1000)} secondes.`);
    } else if ({{ remaining_seconds * 1000 }} > 0) {
        // Si il reste moins de 3 minutes, vérifier immédiatement
        checkForSanctionThresholds();
    }
}

async function checkForSanctionThresholds() {
    if (sanctionNotificationShown) return; // Éviter les notifications multiples
    
    try {
        const response = await fetch('{{ url_for("planning.check_sanction_thresholds") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({
                classroom_id: classroomId,
                initial_counts: initialSanctionCounts
            })
        });
        
        const result = await response.json();
        
        if (result.success && result.threshold_breaches.length > 0) {
            sanctionNotificationShown = true;
            await showSanctionNotification(result.threshold_breaches);
        }
    } catch (error) {
        console.error('Erreur lors de la vérification des seuils:', error);
    }
}

async function showSanctionNotification(breaches) {
    // Créer la notification en haut de la page
    const notification = document.createElement('div');
    notification.className = 'sanction-notification';
    notification.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: linear-gradient(135deg, #FEF3C7 0%, #F59E0B 100%);
        color: #92400E;
        padding: 1rem;
        z-index: 1000;
        border-bottom: 3px solid #F59E0B;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        animation: slideDown 0.5s ease;
    `;
    
    let notificationHTML = `
        <div style="max-width: 1200px; margin: 0 auto;">
            <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
                <i class="fas fa-exclamation-triangle" style="font-size: 1.5rem;"></i>
                <h3 style="margin: 0; font-size: 1.25rem; font-weight: bold;">
                    🎯 Sanctions à attribuer - Demandez aux élèves d'apporter leur agenda
                </h3>
                <button onclick="closeSanctionNotification()" style="margin-left: auto; background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #92400E;">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div style="font-size: 0.95rem; line-height: 1.5;">
    `;
    
    // Traiter chaque seuil franchi
    for (const breach of breaches) {
        let dateInfo = '';
        if (breach.min_days_deadline) {
            try {
                // Calculer la prochaine date de cours
                const dateResponse = await fetch('{{ url_for("planning.calculate_next_lesson_date") }}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    body: JSON.stringify({
                        classroom_id: classroomId,
                        min_days: breach.min_days_deadline,
                        current_date: lessonDate
                    })
                });
                
                const dateResult = await dateResponse.json();
                if (dateResult.success && dateResult.next_date) {
                    dateInfo = ` - <strong>À rendre le ${dateResult.formatted_date}</strong>`;
                    
                    // Ajouter à la planification
                    await fetch('{{ url_for("planning.add_sanction_to_planning") }}', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        body: JSON.stringify({
                            date: dateResult.next_date,
                            period_number: dateResult.period_number,
                            classroom_id: classroomId,
                            student_name: breach.student_name,
                            sanction_text: breach.sanction_text
                        })
                    });
                } else {
                    dateInfo = ' - <em>Date à déterminer</em>';
                }
            } catch (error) {
                console.error('Erreur calcul date:', error);
                dateInfo = ' - <em>Date à déterminer</em>';
            }
        }
        
        notificationHTML += `
            <div style="background: rgba(255, 255, 255, 0.3); padding: 0.75rem; margin: 0.5rem 0; border-radius: 0.5rem; border-left: 4px solid #F59E0B;">
                <strong>${breach.student_name}</strong> - ${breach.sanction_template} (${breach.threshold} coches) : 
                <strong>${breach.sanction_text}</strong>${dateInfo}
            </div>
        `;
    }
    
    notificationHTML += `
            </div>
        </div>
    `;
    
    notification.innerHTML = notificationHTML;
    document.body.appendChild(notification);
    
    // Ajouter le CSS pour l'animation
    if (!document.getElementById('sanction-notification-styles')) {
        const style = document.createElement('style');
        style.id = 'sanction-notification-styles';
        style.textContent = `
            @keyframes slideDown {
                from {
                    transform: translateY(-100%);
                    opacity: 0;
                }
                to {
                    transform: translateY(0);
                    opacity: 1;
                }
            }
            @keyframes slideUp {
                from {
                    transform: translateY(0);
                    opacity: 1;
                }
                to {
                    transform: translateY(-100%);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);
    }
    
    // Décaler le contenu principal vers le bas
    document.body.style.paddingTop = notification.offsetHeight + 'px';
}

function closeSanctionNotification() {
    const notification = document.querySelector('.sanction-notification');
    if (notification) {
        notification.style.animation = 'slideUp 0.5s ease';
        setTimeout(() => {
            notification.remove();
            document.body.style.paddingTop = '0';
        }, 500);
    }
}

// Fonctions pour la gestion des sanctions
async function updateSanctionCount(studentId, sanctionId, delta) {
    const countElement = document.querySelector(`[data-student="${studentId}"][data-sanction="${sanctionId}"]`);
    const currentCount = parseInt(countElement.textContent);
    const newCount = Math.max(0, currentCount + delta); // Ne pas aller en dessous de 0
    
    try {
        const response = await fetch('{{ url_for("planning.update_sanction_count") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({
                student_id: studentId,
                template_id: sanctionId,
                count: newCount
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            countElement.textContent = result.new_count;
            
            // Mettre à jour les classes CSS selon le nombre
            countElement.className = 'count-display';
            if (result.new_count >= 6) {
                countElement.classList.add('danger');
            } else if (result.new_count >= 3) {
                countElement.classList.add('warning');
            }
            
            // Animation de mise à jour
            countElement.style.transform = 'scale(1.2)';
            setTimeout(() => {
                countElement.style.transform = 'scale(1)';
            }, 200);
        } else {
            alert(result.message || 'Erreur lors de la mise à jour');
        }
    } catch (error) {
        console.error('Erreur:', error);
        alert('Erreur lors de la communication avec le serveur');
    }
}

// Initialiser les classes CSS des compteurs au chargement de la page
document.addEventListener('DOMContentLoaded', function() {
    // Appliquer les classes CSS aux compteurs selon leur valeur
    document.querySelectorAll('.count-display').forEach(element => {
        const count = parseInt(element.textContent);
        if (count >= 6) {
            element.classList.add('danger');
        } else if (count >= 3) {
            element.classList.add('warning');
        }
    });
    
    // Initialiser le système de surveillance des sanctions
    initializeSanctionSystem();
    
    // Gestionnaire de redimensionnement pour le plan de classe
    {% if seating_plan %}
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            const seatingContent = document.getElementById('seating-plan-content');
            if (seatingContent && seatingContent.classList.contains('active')) {
                adjustSeatingScale();
            }
        }, 250);
    });
    {% endif %}
});

// Fonction pour afficher des infos debug dans le panneau
function updateDebugPanel(message) {
    const debugPanel = document.getElementById('js-debug-info');
    if (debugPanel) {
        debugPanel.innerHTML += '<div>' + message + '</div>';
    }
}

// Fonction pour charger et afficher le plan de classe
function loadSeatingPlan() {
    {% if seating_plan %}
    console.log('Chargement du plan de classe...');
    
    const workspace = document.getElementById('seating-workspace');
    const viewer = document.getElementById('seating-plan-viewer');
    
    if (!workspace || !viewer) {
        console.error('Workspace ou viewer non trouvé');
        return;
    }
    
    // Nettoyer le workspace
    workspace.innerHTML = '';
    workspace.style.transform = 'none';
    
    // Récupérer les données du plan
    const planData = {{ seating_plan.plan_data | tojson | safe }};
    console.log('Données du plan:', planData);
    
    const elements = planData.elements || [];
    const studentsPlacement = planData.students_placement || [];
    
    // Créer les éléments du plan
    elements.forEach((elementData) => {
        const element = createSeatingElement(elementData);
        if (element) {
            element.style.left = elementData.x + 'px';
            element.style.top = elementData.y + 'px';
            workspace.appendChild(element);
        }
    });
    
    // Données des étudiants
    const studentsData = [
        {% for student in students %}
        {
            id: {{ student.id }},
            first_name: "{{ student.first_name }}",
            last_name: "{{ student.last_name or '' }}",
            full_name: "{{ student.full_name }}"
        }{% if not loop.last %},{% endif %}
        {% endfor %}
    ];
    
    // Placer les étudiants
    studentsPlacement.forEach((placement) => {
        const element = workspace.querySelector(`[data-element-id="${placement.element_id}"]`);
        if (element) {
            const slots = element.querySelectorAll('.student-slot');
            if (slots[placement.slot_index]) {
                const slot = slots[placement.slot_index];
                const student = studentsData.find(s => 
                    s.id === placement.student_id || String(s.id) === String(placement.student_id)
                );
                
                if (student) {
                    slot.innerHTML = `<div class="student-placed">${student.full_name}</div>`;
                    slot.classList.add('occupied');
                }
            }
        }
    });
    
    // Ajuster l'échelle après le chargement
    setTimeout(() => {
        adjustSeatingScale();
    }, 200);
    {% endif %}
}

// Fonction pour créer un élément du plan
function createSeatingElement(elementData) {
    const element = document.createElement('div');
    element.className = 'seating-element';
    element.dataset.elementId = elementData.id;
    element.style.position = 'absolute';
    
    if (elementData.type === 'desk-single') {
        element.className += ' desk-single';
        element.style.width = '80px';
        element.style.height = '60px';
        element.innerHTML = '<div class="student-slots"><div class="student-slot"></div></div>';
    } else if (elementData.type === 'desk-double') {
        element.className += ' desk-double';
        element.style.width = '140px';
        element.style.height = '60px';
        element.innerHTML = '<div class="student-slots"><div class="student-slot"></div><div class="student-slot"></div></div>';
    } else if (elementData.type === 'teacher-desk') {
        element.className += ' teacher-desk';
        element.style.width = '120px';
        element.style.height = '80px';
        element.innerHTML = 'Bureau du professeur';
    }
    
    return element;
}

// Fonction pour ajuster l'échelle du plan pour qu'il s'adapte au conteneur
function adjustSeatingScale() {
    const workspace = document.getElementById('seating-workspace');
    const viewer = document.getElementById('seating-plan-viewer');
    
    if (!workspace || !viewer) return;
    
    // Attendre que le viewer ait une taille
    if (viewer.offsetWidth === 0) {
        setTimeout(adjustSeatingScale, 100);
        return;
    }
    
    const elements = workspace.querySelectorAll('.seating-element');
    if (elements.length === 0) return;
    
    // Calculer les limites du contenu
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
    elements.forEach(element => {
        const x = parseFloat(element.style.left) || 0;
        const y = parseFloat(element.style.top) || 0;
        const width = element.offsetWidth;
        const height = element.offsetHeight;
        
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x + width);
        maxY = Math.max(maxY, y + height);
    });
    
    // Ajouter une marge
    const margin = 40;
    minX -= margin;
    minY -= margin;
    maxX += margin;
    maxY += margin;
    
    // Calculer les dimensions du contenu
    const contentWidth = maxX - minX;
    const contentHeight = maxY - minY;
    
    // Obtenir les dimensions du viewer
    const viewerWidth = viewer.offsetWidth;
    const viewerHeight = viewer.offsetHeight || 400; // Hauteur par défaut
    
    // Calculer l'échelle pour adapter le contenu
    const scaleX = viewerWidth / contentWidth;
    const scaleY = viewerHeight / contentHeight;
    const scale = Math.min(scaleX, scaleY, 1); // Ne pas agrandir au-delà de 100%
    
    // Centrer le contenu
    const scaledWidth = contentWidth * scale;
    const scaledHeight = contentHeight * scale;
    const translateX = (viewerWidth - scaledWidth) / 2 - minX * scale;
    const translateY = (viewerHeight - scaledHeight) / 2 - minY * scale;
    
    // Appliquer la transformation
    workspace.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    workspace.style.transformOrigin = '0 0';
    
    console.log(`Plan ajusté: échelle ${scale}, translation (${translateX}, ${translateY})`);
}


</script>

<style>
.add-resource-btn, .edit-planning-btn {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.375rem 0.75rem;
    background-color: transparent;
    color: var(--primary-color);
    border: 1px solid var(--primary-color);
    border-radius: var(--border-radius);
    text-decoration: none;
    font-size: 0.875rem;
    transition: all 0.3s ease;
    cursor: pointer;
}

.add-resource-btn:hover, .edit-planning-btn:hover {
    background-color: var(--primary-color);
    color: white;
}

.add-resource-btn {
    background-color: var(--primary-color);
    color: white;
}

.add-resource-btn:hover {
    background-color: var(--primary-hover);
}

/* Styles pour le formulaire de planification */
#planningEdit {
    animation: fadeIn 0.3s ease;
}

#planningForm .form-group {
    margin-bottom: 1rem;
}

#planningForm .form-label {
    display: block;
    margin-bottom: 0.5rem;
    font-weight: 500;
    color: var(--dark-color);
}

#planningForm .form-control {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid #D1D5DB;
    border-radius: var(--border-radius);
    font-size: 1rem;
    transition: border-color 0.3s ease;
    font-family: inherit;
}

#planningForm .form-control:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
}

#planningForm textarea.form-control {
    resize: vertical;
    min-height: 120px;
}

.form-actions {
    display: flex;
    gap: 1rem;
    margin-top: 1.5rem;
}

.form-actions button {
    flex: 1;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes slideInNotification {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes slideOutNotification {
    from {
        transform: translateX(0);
        opacity: 1;
    }
    to {
        transform: translateX(100%);
        opacity: 0;
    }
}

/* Animation pour le changement de vue */
.planning-content > div {
    transition: opacity 0.2s ease;
}

/* Styles pour les ressources */
.resource-controls {
    display: flex;
    gap: 0.5rem;
    align-items: center;
}

.resource-btn {
    width: 32px;
    height: 32px;
    border: 1px solid var(--primary-color);
    background-color: transparent;
    color: var(--primary-color);
    border-radius: var(--border-radius);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
}

.resource-btn:hover {
    background-color: var(--primary-color);
    color: white;
}

.resources-loading {
    text-align: center;
    padding: 2rem;
    color: var(--gray-color);
}

.resources-loading i {
    font-size: 1.5rem;
    margin-bottom: 0.5rem;
}

.pinned-resources {
    margin-bottom: 1.5rem;
}

.pinned-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0;
    border-bottom: 1px solid var(--light-gray);
    margin-bottom: 0.75rem;
    font-weight: 600;
    color: var(--primary-color);
    font-size: 0.875rem;
}

.pinned-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.folder-navigation {
    margin-bottom: 1rem;
    background-color: #F8FAFC;
    border: 1px solid #E5E7EB;
    border-radius: 0.5rem;
    padding: 0.5rem;
}

.resource-breadcrumb {
    display: flex;
    align-items: center;
    gap: 0.125rem;
    font-size: 0.8rem;
    overflow-x: auto;
    white-space: nowrap;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.resource-breadcrumb::-webkit-scrollbar {
    display: none;
}

.breadcrumb-item {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.25rem 0.5rem;
    border-radius: 0.375rem;
    cursor: pointer;
    transition: all 0.15s ease;
    color: #6B7280;
    background-color: transparent;
    flex-shrink: 0;
    font-weight: 400;
}

.breadcrumb-item:hover {
    background-color: #E5E7EB;
    color: #374151;
}

.breadcrumb-item.active {
    background-color: var(--primary-color);
    color: white;
    font-weight: 500;
}

.breadcrumb-separator {
    color: #9CA3AF;
    margin: 0 0.125rem;
    font-size: 0.75rem;
    flex-shrink: 0;
}

.resources-tree {
    display: flex;
    flex-direction: column;
    gap: 1px;
    border: 1px solid #E5E7EB;
    border-radius: 0.5rem;
    overflow: hidden;
    background-color: white;
}

.resource-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    background-color: white;
    transition: all 0.15s ease;
    cursor: pointer;
    border-bottom: 1px solid #F3F4F6;
    min-height: 44px;
}

.resource-item:last-child {
    border-bottom: none;
}

.resource-item:hover {
    background-color: #F8FAFC;
}

.resource-item.pinned {
    background-color: #FFFBEB;
    border-left: 3px solid #F59E0B;
}

.resource-item.pinned:hover {
    background-color: #FEF3C7;
}

.resource-item.folder {
    background-color: #F0F9FF;
    border-left: 3px solid #3B82F6;
    font-weight: 500;
}

.resource-item.folder:hover {
    background-color: #E0F2FE;
}

.resource-icon {
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.875rem;
    flex-shrink: 0;
}

.resource-icon.pdf {
    color: #DC2626;
}

.resource-icon.image {
    color: #059669;
}

.resource-icon.folder {
    color: #3B82F6;
}

.resource-icon.pinned {
    color: #F59E0B;
}

.resource-info {
    flex: 1;
    min-width: 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.resource-main {
    flex: 1;
    min-width: 0;
}

.resource-name {
    font-weight: 400;
    color: var(--dark-color);
    font-size: 0.875rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    line-height: 1.2;
}

.resource-item.folder .resource-name {
    font-weight: 500;
    color: #1E40AF;
}

.resource-meta {
    font-size: 0.75rem;
    color: #6B7280;
    display: flex;
    gap: 0.75rem;
    margin-top: 0.125rem;
    white-space: nowrap;
}

.resource-actions {
    display: flex;
    gap: 0.25rem;
    flex-shrink: 0;
    margin-left: 0.5rem;
}

.resource-action-btn {
    width: 24px;
    height: 24px;
    border: none;
    background-color: transparent;
    color: #9CA3AF;
    border-radius: 0.25rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s ease;
    opacity: 0;
    font-size: 0.75rem;
}

.resource-item:hover .resource-action-btn {
    opacity: 1;
}

.resource-action-btn:hover {
    background-color: #F3F4F6;
    color: var(--primary-color);
}

.resource-action-btn.pinned {
    color: #F59E0B;
    opacity: 1;
}

.resource-action-btn.pinned:hover {
    background-color: #FEF3C7;
}

/* Styles pour les fichiers annotables */
.clickable-file {
    cursor: pointer;
    color: var(--primary-color) !important;
    font-weight: 500;
    transition: all 0.2s ease;
}

.clickable-file:hover {
    text-decoration: underline;
    color: var(--primary-hover) !important;
}

.annotatable-badge {
    background-color: #10B981;
    color: white;
    padding: 0.125rem 0.375rem;
    border-radius: 0.25rem;
    font-size: 0.6rem;
    font-weight: 600;
}

/* Responsive */
@media (max-width: 1200px) {
    .resource-meta {
        flex-direction: column;
        gap: 0.25rem;
    }
    
    .resource-actions {
        flex-direction: column;
    }
}

/* Styles pour le plan de classe dans l'onglet */
.seating-plan-container {
    height: 100%;
    padding: 1rem;
}

.seating-plan-viewer {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    position: relative;
    overflow: hidden;
    width: 100%;
    height: 400px;
}

.seating-workspace {
    width: 100%;
    height: 100%;
    position: relative;
    background: white;
    background-image: radial-gradient(circle, #e9ecef 1px, transparent 1px);
    background-size: 20px 20px;
}

/* Éléments du plan */
.seating-element {
    position: absolute;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.8rem;
    font-weight: 500;
    cursor: default;
    user-select: none;
}

.desk-single {
    background: #e3f2fd;
    border: 2px solid #2196f3;
    color: #1976d2;
}

.desk-double {
    background: #f3e5f5;
    border: 2px solid #9c27b0;
    color: #7b1fa2;
}

.teacher-desk {
    background: #fff3e0;
    border: 2px solid #ff9800;
    color: #f57c00;
    font-weight: 600;
}

.student-slots {
    display: flex;
    gap: 4px;
    justify-content: center;
    align-items: center;
    height: 100%;
    padding: 4px;
}

.student-slot {
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: white;
    height: 80%;
    min-width: 30px;
    font-size: 0.7rem;
    text-align: center;
    padding: 2px 4px;
    overflow: hidden;
    flex: 1;
}

.student-slot.occupied {
    background: #4caf50;
    border-color: #388e3c;
    color: white;
}

.student-placed {
    color: white;
    font-size: 0.65rem;
    line-height: 1.1;
    text-align: center;
    font-weight: 600;
    width: 100%;
    white-space: normal;
    word-wrap: break-word;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* Styles pour le Modal Viewer/Annotateur Amélioré */
.file-viewer-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.95);
    z-index: 10000;
    display: none;
    flex-direction: column;
}

.file-viewer-modal.show {
    display: flex;
}

.viewer-header {
    background-color: #f8fafc;
    color: #2d3748;
    padding: 0.75rem 2rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid #e2e8f0;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    z-index: 1;
    position: relative;
}

.viewer-title {
    display: flex;
    align-items: center;
    gap: 1rem;
    font-size: 0.95rem;
    font-weight: 500;
}

.page-info {
    font-size: 0.9rem;
    color: #718096;
    font-weight: normal;
    background-color: #edf2f7;
    padding: 0.25rem 0.75rem;
    border-radius: 0.375rem;
    border: 1px solid #e2e8f0;
}

.viewer-tools {
    display: flex;
    align-items: center;
    gap: 1.5rem;
    flex-wrap: nowrap;
}

.tool-group {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding-right: 1.5rem;
    border-right: 1px solid #e2e8f0;
}

.tool-group:last-child {
    border-right: none;
    padding-right: 0;
}

.tool-btn {
    width: 40px;
    height: 40px;
    border: 1px solid #e2e8f0;
    background-color: #ffffff;
    color: #4a5568;
    border-radius: 0.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.tool-btn:hover {
    background-color: #f7fafc;
    border-color: #cbd5e0;
    transform: translateY(-1px);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
}

.tool-btn.active {
    background-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3);
}

.color-picker-container {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background-color: #ffffff;
    padding: 0.5rem;
    border-radius: 0.5rem;
    border: 1px solid #e2e8f0;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    position: relative;
    z-index: 1;
}

.preset-colors {
    display: flex;
    gap: 0.25rem;
    align-items: center;
}

.color-btn {
    width: 28px;
    height: 28px;
    border: 2px solid transparent;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
    z-index: 1;
}

.color-btn:hover {
    transform: scale(1.1);
    border-color: white;
}

.color-btn.active {
    border-color: white;
    box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
}

.color-picker-container input[type="color"] {
    width: 32px;
    height: 32px;
    border: 2px solid transparent;
    border-radius: 0.5rem;
    cursor: pointer;
    background: none;
}

.stroke-width-container {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background-color: #4A5568;
    padding: 0.5rem;
    border-radius: 0.5rem;
    position: relative;
    z-index: 10;
}

.stroke-width-container input[type="range"] {
    width: 80px;
    -webkit-appearance: none;
    appearance: none;
    height: 6px;
    background: #6B7280;
    outline: none;
    border-radius: 3px;
    cursor: pointer;
}

.stroke-width-container input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    background: #fff;
    cursor: pointer;
    border-radius: 50%;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.stroke-width-container input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background: #fff;
    cursor: pointer;
    border-radius: 50%;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    border: none;
}

#strokeWidthValue {
    min-width: 20px;
    text-align: center;
    font-size: 0.9rem;
}

.close-viewer {
    width: 40px;
    height: 40px;
    border: none;
    background-color: #E53E3E;
    color: white;
    border-radius: 0.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
}

.close-viewer:hover {
    background-color: #C53030;
    transform: scale(1.05);
}

.viewer-content {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    position: relative;
    z-index: 0;
}

.viewer-container {
    max-width: 100%;
    max-height: 100%;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Styles d'annotation canvas supprimés - dupliqués plus bas */

.pdf-container, .image-container {
    position: relative;
    display: inline-block;
}

.viewer-footer {
    background-color: #2D3748;
    color: white;
    padding: 0.75rem 2rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-top: 1px solid #4A5568;
}

.save-status {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: #68D391;
    font-size: 0.9rem;
}

.save-status.saving {
    color: #F6AD55;
}

.save-status.error {
    color: #FC8181;
}

/* Styles pour la nouvelle interface améliorée */
/* Styles zoomLevel supprimés */

.viewer-content {
    flex: 1;
    display: flex;
    overflow: hidden;
    position: relative;
}

/* Barre latérale des pages - permanente à gauche */
.page-sidebar {
    width: 220px;
    background-color: #f8fafc;
    border-right: 1px solid #e2e8f0;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
}

.page-sidebar.show {
    display: flex;
}

.sidebar-header {
    padding: 1rem;
    border-bottom: 1px solid #e2e8f0;
    display: flex;
    justify-content: center;
    align-items: center;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
}

.sidebar-header h6 {
    margin: 0;
    color: white;
    font-size: 0.9rem;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}


/* Zone de miniatures scrollable moderne */
.page-thumbnails {
    flex: 1;
    overflow-y: auto;
    padding: 1rem 0.75rem;
    scrollbar-width: thin;
    scrollbar-color: #cbd5e0 #f1f5f9;
}

.page-thumbnails.scrollable {
    max-height: calc(100vh - 200px);
}

.page-thumbnails::-webkit-scrollbar {
    width: 8px;
}

.page-thumbnails::-webkit-scrollbar-track {
    background: #f1f5f9;
    border-radius: 4px;
}

.page-thumbnails::-webkit-scrollbar-thumb {
    background: #cbd5e0;
    border-radius: 4px;
    transition: background 0.2s ease;
}

.page-thumbnails::-webkit-scrollbar-thumb:hover {
    background: #a0aec0;
}

.thumbnail-item {
    margin-bottom: 0.75rem;
    border: 2px solid transparent;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    overflow: hidden;
    background: white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.thumbnail-item:hover {
    border-color: #667eea;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.thumbnail-item.active {
    border-color: #4f46e5;
    box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
}

.thumbnail-canvas {
    width: 100%;
    display: block;
    border-radius: 0.25rem;
}

/* Zone d'affichage principal */
.viewer-container {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: auto;
    padding: 1rem;
    background-color: #f7fafc;
    position: relative;
}

.pdf-viewer-container {
    position: relative;
    background: white;
    border-radius: 0.5rem;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
    overflow: hidden;
    transform-origin: center;
    transition: transform 0.2s ease;
}

.pdf-canvas {
    display: block;
    border-radius: 0.5rem;
}

.annotation-canvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 10;
    cursor: crosshair;
    border-radius: 0.5rem;
    width: 100%;
    height: 100%;
    pointer-events: auto;
}

/* États des boutons */
.tool-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.tool-btn:disabled:hover {
    background-color: #4A5568;
    transform: none;
}

/* Animation de chargement */
@keyframes pulse {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.5;
    }
}

.loading {
    animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Styles pour les erreurs */
.error-message {
    color: #fc8181;
    text-align: center;
    padding: 2rem;
    background-color: #fed7d7;
    border-radius: 0.5rem;
    margin: 1rem;
}

/* Responsive pour le viewer amélioré */
@media (max-width: 768px) {
    .viewer-header {
        padding: 0.75rem 1rem;
        flex-wrap: wrap;
        gap: 1rem;
    }
    
    .viewer-tools {
        gap: 0.5rem;
        flex-wrap: wrap;
    }
    
    .tool-group {
        padding-right: 0.5rem;
        border-right: none;
        border-bottom: 1px solid #4a5568;
        padding-bottom: 0.5rem;
        margin-bottom: 0.5rem;
    }
    
    .tool-group:last-child {
        border-bottom: none;
        margin-bottom: 0;
    }
    
    .tool-btn {
        width: 35px;
        height: 35px;
    }
    
    .stroke-width-container input[type="range"] {
        width: 60px;
    }
    
    .viewer-footer {
        padding: 0.5rem 1rem;
    }
    
    .page-sidebar {
        width: 180px;
    }
    
    .page-sidebar.show {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        z-index: 100;
        box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
    }
    
    .viewer-container {
        padding: 0.5rem;
    }
    
    .viewer-title {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.25rem;
    }
    
    /* Styles zoomLevel responsive supprimés */
}

@media (max-width: 480px) {
    .viewer-header {
        padding: 0.5rem;
    }
    
    .viewer-tools {
        justify-content: center;
        width: 100%;
    }
    
    .tool-group {
        gap: 0.25rem;
    }
    
    .tool-btn {
        width: 32px;
        height: 32px;
        font-size: 0.8rem;
    }
    
    .color-btn {
        width: 24px;
        height: 24px;
    }
    
    .page-sidebar {
        width: 160px;
    }
}
</style>
{% endblock %}
